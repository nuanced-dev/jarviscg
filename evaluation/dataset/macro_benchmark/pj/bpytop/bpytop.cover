       #!/usr/bin/env python3
       # pylint: disable=not-callable, no-member, unsubscriptable-object
       # indent = tab
       # tab-size = 4
       
       # Copyright 2021 Aristocratos (jakob@qvantnet.com)
       
       #    Licensed under the Apache License, Version 2.0 (the "License");
       #    you may not use this file except in compliance with the License.
       #    You may obtain a copy of the License at
       
       #        http://www.apache.org/licenses/LICENSE-2.0
       
       #    Unless required by applicable law or agreed to in writing, software
       #    distributed under the License is distributed on an "AS IS" BASIS,
       #    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       #    See the License for the specific language governing permissions and
       #    limitations under the License.
       
    1: import threading,os,sys,io, signal, re, subprocess, logging, logging.handlers, argparse
    1: import urllib.request
    1: from time import time, sleep, strftime, tzset
    1: from datetime import timedelta
    1: from _thread import interrupt_main
    1: from collections import defaultdict
    1: from select import select
    1: from string import Template
    1: from math import ceil, floor
    1: from random import randint
    1: from shutil import which
    1: from typing import List, Dict, Tuple, Union, Any, Iterable
       
    1: errors: List[str] = []
    1: try: import fcntl, termios, tty, pwd
       except Exception as e: errors.append(f'{e}')
       
    1: try: import psutil # type: ignore
       except Exception as e: errors.append(f'{e}')
       
    1: SELF_START = time()
       
    1: SYSTEM: str
    1: if "linux" in sys.platform: SYSTEM = "Linux"
    1: elif "bsd" in sys.platform: SYSTEM = "BSD"
    1: elif "darwin" in sys.platform: SYSTEM = "MacOS"
       else: SYSTEM = "Other"
       
    1: if errors:
               print("ERROR!")
               print("\n".join(errors))
               if SYSTEM == "Other":
                       print("\nUnsupported platform!\n")
               else:
                       print("\nInstall required modules!\n")
               raise SystemExit(1)
       
    1: VERSION: str = "1.0.68"
       
       #? Argument parser ------------------------------------------------------------------------------->
    1: args = argparse.ArgumentParser()
    1: args.add_argument("-b", "--boxes",              action="store", dest="boxes",   help = "which boxes to show at start, example: -b \"cpu mem net proc\"")
    1: args.add_argument("-lc", "--low-color", action="store_true",                    help = "disable truecolor, converts 24-bit colors to 256-color")
    1: args.add_argument("-v", "--version",    action="store_true",                    help = "show version info and exit")
    1: args.add_argument("--debug",                    action="store_true",                    help = "start with loglevel set to DEBUG overriding value set in config")
    1: stdargs = args.parse_args()
       
    1: if stdargs.version:
               print(f'bpytop version: {VERSION}\n'
                       f'psutil version: {".".join(str(x) for x in psutil.version_info)}')
               raise SystemExit(0)
       
    1: ARG_BOXES: str = stdargs.boxes
    1: LOW_COLOR: bool = stdargs.low_color
    1: DEBUG: bool = stdargs.debug
       
       #? Variables ------------------------------------------------------------------------------------->
       
    1: BANNER_SRC: List[Tuple[str, str, str]] = [
    1:         ("#ffa50a", "#0fd7ff", "██████╗ ██████╗ ██╗   ██╗████████╗ ██████╗ ██████╗"),
    1:         ("#f09800", "#00bfe6", "██╔══██╗██╔══██╗╚██╗ ██╔╝╚══██╔══╝██╔═══██╗██╔══██╗"),
    1:         ("#db8b00", "#00a6c7", "██████╔╝██████╔╝ ╚████╔╝    ██║   ██║   ██║██████╔╝"),
    1:         ("#c27b00", "#008ca8", "██╔══██╗██╔═══╝   ╚██╔╝     ██║   ██║   ██║██╔═══╝ "),
    1:         ("#a86b00", "#006e85", "██████╔╝██║        ██║      ██║   ╚██████╔╝██║"),
    1:         ("#000000", "#000000", "╚═════╝ ╚═╝        ╚═╝      ╚═╝    ╚═════╝ ╚═╝"),
       ]
       
       #*?This is the template used to create the config file
    1: DEFAULT_CONF: Template = Template(f'#? Config file for bpytop v. {VERSION}' + '''
       
       #* Color theme, looks for a .theme file in "/usr/[local/]share/bpytop/themes" and "~/.config/bpytop/themes", "Default" for builtin default theme.
       #* Prefix name by a plus sign (+) for a theme located in user themes folder, i.e. color_theme="+monokai"
       color_theme="$color_theme"
       
       #* If the theme set background should be shown, set to False if you want terminal background transparency
       theme_background=$theme_background
       
       #* Sets if 24-bit truecolor should be used, will convert 24-bit colors to 256 color (6x6x6 color cube) if false.
       truecolor=$truecolor
       
       #* Manually set which boxes to show. Available values are "cpu mem net proc", separate values with whitespace.
       shown_boxes="$shown_boxes"
       
       #* Update time in milliseconds, increases automatically if set below internal loops processing time, recommended 2000 ms or above for better sample times for graphs.
       update_ms=$update_ms
       
       #* Processes update multiplier, sets how often the process list is updated as a multiplier of "update_ms".
       #* Set to 2 or higher to greatly decrease bpytop cpu usage. (Only integers)
       proc_update_mult=$proc_update_mult
       
       #* Processes sorting, "pid" "program" "arguments" "threads" "user" "memory" "cpu lazy" "cpu responsive",
       #* "cpu lazy" updates top process over time, "cpu responsive" updates top process directly.
       proc_sorting="$proc_sorting"
       
       #* Reverse sorting order, True or False.
       proc_reversed=$proc_reversed
       
       #* Show processes as a tree
       proc_tree=$proc_tree
       
       #* Which depth the tree view should auto collapse processes at
       tree_depth=$tree_depth
       
       #* Use the cpu graph colors in the process list.
       proc_colors=$proc_colors
       
       #* Use a darkening gradient in the process list.
       proc_gradient=$proc_gradient
       
       #* If process cpu usage should be of the core it's running on or usage of the total available cpu power.
       proc_per_core=$proc_per_core
       
       #* Show process memory as bytes instead of percent
       proc_mem_bytes=$proc_mem_bytes
       
       #* Sets the CPU stat shown in upper half of the CPU graph, "total" is always available, see:
       #* https://psutil.readthedocs.io/en/latest/#psutil.cpu_times for attributes available on specific platforms.
       #* Select from a list of detected attributes from the options menu
       cpu_graph_upper="$cpu_graph_upper"
       
       #* Sets the CPU stat shown in lower half of the CPU graph, "total" is always available, see:
       #* https://psutil.readthedocs.io/en/latest/#psutil.cpu_times for attributes available on specific platforms.
       #* Select from a list of detected attributes from the options menu
       cpu_graph_lower="$cpu_graph_lower"
       
       #* Toggles if the lower CPU graph should be inverted.
       cpu_invert_lower=$cpu_invert_lower
       
       #* Set to True to completely disable the lower CPU graph.
       cpu_single_graph=$cpu_single_graph
       
       #* Shows the system uptime in the CPU box.
       show_uptime=$show_uptime
       
       #* Check cpu temperature, needs "osx-cpu-temp" on MacOS X.
       check_temp=$check_temp
       
       #* Which sensor to use for cpu temperature, use options menu to select from list of available sensors.
       cpu_sensor=$cpu_sensor
       
       #* Show temperatures for cpu cores also if check_temp is True and sensors has been found
       show_coretemp=$show_coretemp
       
       #* Which temperature scale to use, available values: "celsius", "fahrenheit", "kelvin" and "rankine"
       temp_scale="$temp_scale"
       
       #* Show CPU frequency, can cause slowdowns on certain systems with some versions of psutil
       show_cpu_freq=$show_cpu_freq
       
       #* Draw a clock at top of screen, formatting according to strftime, empty string to disable.
       draw_clock="$draw_clock"
       
       #* Update main ui in background when menus are showing, set this to false if the menus is flickering too much for comfort.
       background_update=$background_update
       
       #* Custom cpu model name, empty string to disable.
       custom_cpu_name="$custom_cpu_name"
       
       #* Optional filter for shown disks, should be full path of a mountpoint, separate multiple values with a comma ",".
       #* Begin line with "exclude=" to change to exclude filter, otherwise defaults to "most include" filter. Example: disks_filter="exclude=/boot, /home/user"
       disks_filter="$disks_filter"
       
       #* Show graphs instead of meters for memory values.
       mem_graphs=$mem_graphs
       
       #* If swap memory should be shown in memory box.
       show_swap=$show_swap
       
       #* Show swap as a disk, ignores show_swap value above, inserts itself after first disk.
       swap_disk=$swap_disk
       
       #* If mem box should be split to also show disks info.
       show_disks=$show_disks
       
       #* Filter out non physical disks. Set this to False to include network disks, RAM disks and similar.
       only_physical=$only_physical
       
       #* Read disks list from /etc/fstab. This also disables only_physical.
       use_fstab=$use_fstab
       
       #* Toggles if io stats should be shown in regular disk usage view
       show_io_stat=$show_io_stat
       
       #* Toggles io mode for disks, showing only big graphs for disk read/write speeds.
       io_mode=$io_mode
       
       #* Set to True to show combined read/write io graphs in io mode.
       io_graph_combined=$io_graph_combined
       
       #* Set the top speed for the io graphs in MiB/s (10 by default), use format "device:speed" separate disks with a comma ",".
       #* Example: "/dev/sda:100, /dev/sdb:20"
       io_graph_speeds="$io_graph_speeds"
       
       #* Set fixed values for network graphs, default "10M" = 10 Mibibytes, possible units "K", "M", "G", append with "bit" for bits instead of bytes, i.e "100mbit"
       net_download="$net_download"
       net_upload="$net_upload"
       
       #* Start in network graphs auto rescaling mode, ignores any values set above and rescales down to 10 Kibibytes at the lowest.
       net_auto=$net_auto
       
       #* Sync the scaling for download and upload to whichever currently has the highest scale
       net_sync=$net_sync
       
       #* If the network graphs color gradient should scale to bandwidth usage or auto scale, bandwidth usage is based on "net_download" and "net_upload" values
       net_color_fixed=$net_color_fixed
       
       #* Starts with the Network Interface specified here.
       net_iface="$net_iface"
       
       #* Show battery stats in top right if battery is present
       show_battery=$show_battery
       
       #* Show init screen at startup, the init screen is purely cosmetical
       show_init=$show_init
       
       #* Enable check for new version from github.com/aristocratos/bpytop at start.
       update_check=$update_check
       
       #* Set loglevel for "~/.config/bpytop/error.log" levels are: "ERROR" "WARNING" "INFO" "DEBUG".
       #* The level set includes all lower levels, i.e. "DEBUG" will show all logging info.
       log_level=$log_level
       ''')
       
    1: CONFIG_DIR: str = f'{os.path.expanduser("~")}/.config/bpytop'
    1: if not os.path.isdir(CONFIG_DIR):
               try:
                       os.makedirs(CONFIG_DIR)
                       os.mkdir(f'{CONFIG_DIR}/themes')
               except PermissionError:
                       print(f'ERROR!\nNo permission to write to "{CONFIG_DIR}" directory!')
                       raise SystemExit(1)
    1: CONFIG_FILE: str = f'{CONFIG_DIR}/bpytop.conf'
    1: THEME_DIR: str = ""
       
    1: if os.path.isdir(f'{os.path.dirname(__file__)}/bpytop-themes'):
               THEME_DIR = f'{os.path.dirname(__file__)}/bpytop-themes'
    1: elif os.path.isdir(f'{os.path.dirname(__file__)}/themes'):
               THEME_DIR = f'{os.path.dirname(__file__)}/themes'
       else:
    4:         for td in ["/usr/local/", "/usr/", "/snap/bpytop/current/usr/"]:
    3:                 if os.path.isdir(f'{td}share/bpytop/themes'):
                               THEME_DIR = f'{td}share/bpytop/themes'
                               break
    1: USER_THEME_DIR: str = f'{CONFIG_DIR}/themes'
       
    1: CORES: int = psutil.cpu_count(logical=False) or 1
    1: THREADS: int = psutil.cpu_count(logical=True) or 1
       
    1: THREAD_ERROR: int = 0
       
    1: DEFAULT_THEME: Dict[str, str] = {
    1:         "main_bg" : "#00",
    1:         "main_fg" : "#cc",
    1:         "title" : "#ee",
    1:         "hi_fg" : "#969696",
    1:         "selected_bg" : "#7e2626",
    1:         "selected_fg" : "#ee",
    1:         "inactive_fg" : "#40",
    1:         "graph_text" : "#60",
    1:         "meter_bg" : "#40",
    1:         "proc_misc" : "#0de756",
    1:         "cpu_box" : "#3d7b46",
    1:         "mem_box" : "#8a882e",
    1:         "net_box" : "#423ba5",
    1:         "proc_box" : "#923535",
    1:         "div_line" : "#30",
    1:         "temp_start" : "#4897d4",
    1:         "temp_mid" : "#5474e8",
    1:         "temp_end" : "#ff40b6",
    1:         "cpu_start" : "#50f095",
    1:         "cpu_mid" : "#f2e266",
    1:         "cpu_end" : "#fa1e1e",
    1:         "free_start" : "#223014",
    1:         "free_mid" : "#b5e685",
    1:         "free_end" : "#dcff85",
    1:         "cached_start" : "#0b1a29",
    1:         "cached_mid" : "#74e6fc",
    1:         "cached_end" : "#26c5ff",
    1:         "available_start" : "#292107",
    1:         "available_mid" : "#ffd77a",
    1:         "available_end" : "#ffb814",
    1:         "used_start" : "#3b1f1c",
    1:         "used_mid" : "#d9626d",
    1:         "used_end" : "#ff4769",
    1:         "download_start" : "#231a63",
    1:         "download_mid" : "#4f43a3",
    1:         "download_end" : "#b0a9de",
    1:         "upload_start" : "#510554",
    1:         "upload_mid" : "#7d4180",
    1:         "upload_end" : "#dcafde",
    1:         "process_start" : "#80d0a3",
    1:         "process_mid" : "#dcd179",
    1:         "process_end" : "#d45454",
       }
       
    1: MENUS: Dict[str, Dict[str, Tuple[str, ...]]] = {
    1:         "options" : {
    1:                 "normal" : (
                               "┌─┐┌─┐┌┬┐┬┌─┐┌┐┌┌─┐",
                               "│ │├─┘ │ ││ ││││└─┐",
                               "└─┘┴   ┴ ┴└─┘┘└┘└─┘"),
    1:                 "selected" : (
                               "╔═╗╔═╗╔╦╗╦╔═╗╔╗╔╔═╗",
                               "║ ║╠═╝ ║ ║║ ║║║║╚═╗",
                               "╚═╝╩   ╩ ╩╚═╝╝╚╝╚═╝") },
    1:         "help" : {
    1:                 "normal" : (
                               "┬ ┬┌─┐┬  ┌─┐",
                               "├─┤├┤ │  ├─┘",
                               "┴ ┴└─┘┴─┘┴  "),
    1:                 "selected" : (
                               "╦ ╦╔═╗╦  ╔═╗",
                               "╠═╣║╣ ║  ╠═╝",
                               "╩ ╩╚═╝╩═╝╩  ") },
    1:         "quit" : {
    1:                 "normal" : (
                               "┌─┐ ┬ ┬ ┬┌┬┐",
                               "│─┼┐│ │ │ │ ",
                               "└─┘└└─┘ ┴ ┴ "),
    1:                 "selected" : (
                               "╔═╗ ╦ ╦ ╦╔╦╗ ",
                               "║═╬╗║ ║ ║ ║  ",
                               "╚═╝╚╚═╝ ╩ ╩  ") }
       }
       
    1: MENU_COLORS: Dict[str, Tuple[str, ...]] = {
    1:         "normal" : ("#0fd7ff", "#00bfe6", "#00a6c7", "#008ca8"),
    1:         "selected" : ("#ffa50a", "#f09800", "#db8b00", "#c27b00")
       }
       
       #? Units for floating_humanizer function
    1: UNITS: Dict[str, Tuple[str, ...]] = {
    1:         "bit" : ("bit", "Kib", "Mib", "Gib", "Tib", "Pib", "Eib", "Zib", "Yib", "Bib", "GEb"),
    1:         "byte" : ("Byte", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB", "BiB", "GEB")
       }
       
    1: SUBSCRIPT: Tuple[str, ...] = ("₀", "₁", "₂", "₃", "₄", "₅", "₆", "₇", "₈", "₉")
    1: SUPERSCRIPT: Tuple[str, ...] = ("⁰", "¹", "²", "³", "⁴", "⁵", "⁶", "⁷", "⁸", "⁹")
       
       #? Setup error logger ---------------------------------------------------------------->
       
    1: try:
    1:         errlog = logging.getLogger("ErrorLogger")
    1:         errlog.setLevel(logging.DEBUG)
    1:         eh = logging.handlers.RotatingFileHandler(f'{CONFIG_DIR}/error.log', maxBytes=1048576, backupCount=4)
    1:         eh.setLevel(logging.DEBUG)
    1:         eh.setFormatter(logging.Formatter("%(asctime)s | %(levelname)s: %(message)s", datefmt="%d/%m/%y (%X)"))
    1:         errlog.addHandler(eh)
       except PermissionError:
               print(f'ERROR!\nNo permission to write to "{CONFIG_DIR}" directory!')
               raise SystemExit(1)
       
       #? Timers for testing and debugging -------------------------------------------------------------->
       
    2: class TimeIt:
    1:         timers: Dict[str, float] = {}
    1:         paused: Dict[str, float] = {}
       
    1:         @classmethod
    1:         def start(cls, name):
                       cls.timers[name] = time()
       
    1:         @classmethod
    1:         def pause(cls, name):
                       if name in cls.timers:
                               cls.paused[name] = time() - cls.timers[name]
                               del cls.timers[name]
       
    1:         @classmethod
    1:         def stop(cls, name):
                       if name in cls.timers:
                               total: float = time() - cls.timers[name]
                               del cls.timers[name]
                               if name in cls.paused:
                                       total += cls.paused[name]
                                       del cls.paused[name]
                               errlog.debug(f'{name} completed in {total:.6f} seconds')
       
    1: def timeit_decorator(func):
               def timed(*args, **kw):
                       ts = time()
                       out = func(*args, **kw)
                       errlog.debug(f'{func.__name__} completed in {time() - ts:.6f} seconds')
                       return out
               return timed
       
       
       #? Issue #364 ----------------------------------------------------------->
       
    1: def strtobool(val: str) -> bool:
               """Convert a string representation of truth to true (1) or false (0).
       
               True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values
               are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if
               'val' is anything else.
               """
   30:         try:
   30:                 val = val.lower()
               except AttributeError:
                       raise ValueError(f"invalid type {type(val)} for truth value {val}")
   30:         if val in ('y', 'yes', 't', 'true', 'on', '1'):
   20:                 return True
   10:         elif val in ('n', 'no', 'f', 'false', 'off', '0'):
   10:                 return False
               else:
                       raise ValueError(f"invalid truth value {val}")
       
       #? Set up config class and load config ----------------------------------------------------------->
       
    2: class Config:
    1:         '''Holds all config variables and functions for loading from and saving to disk'''
    2:         keys: List[str] = ["color_theme", "update_ms", "proc_sorting", "proc_reversed", "proc_tree", "check_temp", "draw_clock", "background_update", "custom_cpu_name",
    1:                                                 "proc_colors", "proc_gradient", "proc_per_core", "proc_mem_bytes", "disks_filter", "update_check", "log_level", "mem_graphs", "show_swap",
    1:                                                 "swap_disk", "show_disks", "use_fstab", "net_download", "net_upload", "net_auto", "net_color_fixed", "show_init", "theme_background",
    1:                                                 "net_sync", "show_battery", "tree_depth", "cpu_sensor", "show_coretemp", "proc_update_mult", "shown_boxes", "net_iface", "only_physical",
    1:                                                 "truecolor", "io_mode", "io_graph_combined", "io_graph_speeds", "show_io_stat", "cpu_graph_upper", "cpu_graph_lower", "cpu_invert_lower",
    1:                                                 "cpu_single_graph", "show_uptime", "temp_scale", "show_cpu_freq"]
    1:         conf_dict: Dict[str, Union[str, int, bool]] = {}
    1:         color_theme: str = "Default"
    1:         theme_background: bool = True
    1:         truecolor: bool = True
    1:         shown_boxes: str = "cpu mem net proc"
    1:         update_ms: int = 2000
    1:         proc_update_mult: int = 2
    1:         proc_sorting: str = "cpu lazy"
    1:         proc_reversed: bool = False
    1:         proc_tree: bool = False
    1:         tree_depth: int = 3
    1:         proc_colors: bool = True
    1:         proc_gradient: bool = True
    1:         proc_per_core: bool = False
    1:         proc_mem_bytes: bool = True
    1:         cpu_graph_upper: str = "total"
    1:         cpu_graph_lower: str = "total"
    1:         cpu_invert_lower: bool = True
    1:         cpu_single_graph: bool = False
    1:         show_uptime: bool = True
    1:         check_temp: bool = True
    1:         cpu_sensor: str = "Auto"
    1:         show_coretemp: bool = True
    1:         temp_scale: str = "celsius"
    1:         show_cpu_freq: bool = True
    1:         draw_clock: str = "%X"
    1:         background_update: bool = True
    1:         custom_cpu_name: str = ""
    1:         disks_filter: str = ""
    1:         update_check: bool = True
    1:         mem_graphs: bool = True
    1:         show_swap: bool = True
    1:         swap_disk: bool = True
    1:         show_disks: bool = True
    1:         only_physical: bool = True
    1:         use_fstab: bool = False
    1:         show_io_stat: bool = True
    1:         io_mode: bool = False
    1:         io_graph_combined: bool = False
    1:         io_graph_speeds: str = ""
    1:         net_download: str = "10M"
    1:         net_upload: str = "10M"
    1:         net_color_fixed: bool = False
    1:         net_auto: bool = True
    1:         net_sync: bool = False
    1:         net_iface: str = ""
    1:         show_battery: bool = True
    1:         show_init: bool = False
    1:         log_level: str = "WARNING"
       
    1:         warnings: List[str] = []
    1:         info: List[str] = []
       
    1:         sorting_options: List[str] = ["pid", "program", "arguments", "threads", "user", "memory", "cpu lazy", "cpu responsive"]
    1:         log_levels: List[str] = ["ERROR", "WARNING", "INFO", "DEBUG"]
    1:         cpu_percent_fields: List = ["total"]
    1:         cpu_percent_fields.extend(getattr(psutil.cpu_times_percent(), "_fields", []))
    1:         temp_scales: List[str] = ["celsius", "fahrenheit", "kelvin", "rankine"]
       
    1:         cpu_sensors: List[str] = [ "Auto" ]
       
    1:         if hasattr(psutil, "sensors_temperatures"):
                       try:
                               _temps = psutil.sensors_temperatures()
                               if _temps:
                                       for _name, _entries in _temps.items():
                                               for _num, _entry in enumerate(_entries, 1):
                                                       if hasattr(_entry, "current"):
                                                               cpu_sensors.append(f'{_name}:{_num if _entry.label == "" else _entry.label}')
                       except:
                               pass
       
    1:         changed: bool = False
    1:         recreate: bool = False
    1:         config_file: str = ""
       
    1:         _initialized: bool = False
       
    1:         def __init__(self, path: str):
    1:                 self.config_file = path
    1:                 conf: Dict[str, Union[str, int, bool]] = self.load_config()
    1:                 if not "version" in conf.keys():
                               self.recreate = True
                               self.info.append(f'Config file malformatted or missing, will be recreated on exit!')
    1:                 elif conf["version"] != VERSION:
                               self.recreate = True
                               self.info.append(f'Config file version and bpytop version mismatch, will be recreated on exit!')
   49:                 for key in self.keys:
   48:                         if key in conf.keys() and conf[key] != "_error_":
   48:                                 setattr(self, key, conf[key])
                               else:
                                       self.recreate = True
                                       self.conf_dict[key] = getattr(self, key)
    1:                 self._initialized = True
       
    1:         def __setattr__(self, name, value):
   50:                 if self._initialized:
                               object.__setattr__(self, "changed", True)
   50:                 object.__setattr__(self, name, value)
   50:                 if name not in ["_initialized", "recreate", "changed"]:
   49:                         self.conf_dict[name] = value
       
    1:         def load_config(self) -> Dict[str, Union[str, int, bool]]:
                       '''Load config from file, set correct types for values and return a dict'''
    1:                 new_config: Dict[str,Union[str, int, bool]] = {}
    1:                 conf_file: str = ""
    1:                 if os.path.isfile(self.config_file):
    1:                         conf_file = self.config_file
                       elif SYSTEM == "BSD" and os.path.isfile("/usr/local/etc/bpytop.conf"):
                               conf_file = "/usr/local/etc/bpytop.conf"
                       elif SYSTEM != "BSD" and os.path.isfile("/etc/bpytop.conf"):
                               conf_file = "/etc/bpytop.conf"
                       else:
                               return new_config
    1:                 try:
    1:                         with open(conf_file, "r") as f:
  154:                                 for line in f:
  153:                                         line = line.strip()
  153:                                         if line.startswith("#? Config"):
    1:                                                 new_config["version"] = line[line.find("v. ") + 3:]
    1:                                                 continue
  152:                                         if not '=' in line:
  101:                                                 continue
   51:                                         key, line = line.split('=', maxsplit=1)
   51:                                         if not key in self.keys:
    3:                                                 continue
   48:                                         line = line.strip('"')
   48:                                         if type(getattr(self, key)) == int:
    3:                                                 try:
    3:                                                         new_config[key] = int(line)
                                                       except ValueError:
                                                               self.warnings.append(f'Config key "{key}" should be an integer!')
   48:                                         if type(getattr(self, key)) == bool:
   30:                                                 try:
   30:                                                         new_config[key] = bool(strtobool(line))
                                                       except ValueError:
                                                               self.warnings.append(f'Config key "{key}" can only be True or False!')
   48:                                         if type(getattr(self, key)) == str:
   15:                                                 new_config[key] = str(line)
                       except Exception as e:
                               errlog.exception(str(e))
    1:                 if "proc_sorting" in new_config and not new_config["proc_sorting"] in self.sorting_options:
                               new_config["proc_sorting"] = "_error_"
                               self.warnings.append(f'Config key "proc_sorted" didn\'t get an acceptable value!')
    1:                 if "log_level" in new_config and not new_config["log_level"] in self.log_levels:
                               new_config["log_level"] = "_error_"
                               self.warnings.append(f'Config key "log_level" didn\'t get an acceptable value!')
    1:                 if "update_ms" in new_config and int(new_config["update_ms"]) < 100:
                               new_config["update_ms"] = 100
                               self.warnings.append(f'Config key "update_ms" can\'t be lower than 100!')
    3:                 for net_name in ["net_download", "net_upload"]:
    2:                         if net_name in new_config and not new_config[net_name][0].isdigit(): # type: ignore
                                       new_config[net_name] = "_error_"
    1:                 if "cpu_sensor" in new_config and not new_config["cpu_sensor"] in self.cpu_sensors:
                               new_config["cpu_sensor"] = "_error_"
                               self.warnings.append(f'Config key "cpu_sensor" does not contain an available sensor!')
    1:                 if "shown_boxes" in new_config and not new_config["shown_boxes"] == "":
    4:                         for box in new_config["shown_boxes"].split(): #type: ignore
    3:                                 if not box in ["cpu", "mem", "net", "proc"]:
                                               new_config["shown_boxes"] = "_error_"
                                               self.warnings.append(f'Config key "shown_boxes" contains invalid box names!')
                                               break
    3:                 for cpu_graph in ["cpu_graph_upper", "cpu_graph_lower"]:
    2:                         if cpu_graph in new_config and not new_config[cpu_graph] in self.cpu_percent_fields:
                                       new_config[cpu_graph] = "_error_"
                                       self.warnings.append(f'Config key "{cpu_graph}" does not contain an available cpu stat attribute!')
    1:                 if "temp_scale" in new_config and not new_config["temp_scale"] in self.temp_scales:
                               new_config["temp_scale"] = "_error_"
                               self.warnings.append(f'Config key "temp_scale" does not contain a recognized temperature scale!')
    1:                 return new_config
       
    1:         def save_config(self):
                       '''Save current config to config file if difference in values or version, creates a new file if not found'''
    1:                 if not self.changed and not self.recreate: return
                       try:
                               with open(self.config_file, "w" if os.path.isfile(self.config_file) else "x") as f:
                                       f.write(DEFAULT_CONF.substitute(self.conf_dict))
                       except Exception as e:
                               errlog.exception(str(e))
       
    1: try:
    1:         CONFIG: Config = Config(CONFIG_FILE)
    1:         if DEBUG:
                       errlog.setLevel(logging.DEBUG)
               else:
    1:                 errlog.setLevel(getattr(logging, CONFIG.log_level))
    1:                 DEBUG = CONFIG.log_level == "DEBUG"
    1:         errlog.info(f'New instance of bpytop version {VERSION} started with pid {os.getpid()}')
    1:         errlog.info(f'Loglevel set to {"DEBUG" if DEBUG else CONFIG.log_level}')
    5:         errlog.debug(f'Using psutil version {".".join(str(x) for x in psutil.version_info)}')
    1:         errlog.debug(f'CMD: {" ".join(sys.argv)}')
    1:         if CONFIG.info:
                       for info in CONFIG.info:
                               errlog.info(info)
                       CONFIG.info = []
    1:         if CONFIG.warnings:
                       for warning in CONFIG.warnings:
                               errlog.warning(warning)
                       CONFIG.warnings = []
       except Exception as e:
               errlog.exception(f'{e}')
               raise SystemExit(1)
       
    1: if ARG_BOXES:
               _new_boxes: List = []
               for _box in ARG_BOXES.split():
                       if _box in ["cpu", "mem", "net", "proc"]:
                               _new_boxes.append(_box)
               CONFIG.shown_boxes = " ".join(_new_boxes)
               del _box, _new_boxes
       
    1: if SYSTEM == "Linux" and not os.path.isdir("/sys/class/power_supply"):
               CONFIG.show_battery = False
       
    1: if psutil.version_info[0] < 5 or (psutil.version_info[0] == 5 and psutil.version_info[1] < 7):
               warn = f'psutil version {".".join(str(x) for x in psutil.version_info)} detected, version 5.7.0 or later required for full functionality!'
               print("WARNING!", warn)
               errlog.warning(warn)
       
       
       #? Classes --------------------------------------------------------------------------------------->
       
    2: class Term:
    1:         """Terminal info and commands"""
    1:         width: int = 0
    1:         height: int = 0
    1:         resized: bool = False
    1:         _w : int = 0
    1:         _h : int = 0
    1:         fg: str = ""                                                                                            #* Default foreground color
    1:         bg: str = ""                                                                                            #* Default background color
    1:         hide_cursor             = "\033[?25l"                                                   #* Hide terminal cursor
    1:         show_cursor             = "\033[?25h"                                                   #* Show terminal cursor
    1:         alt_screen                      = "\033[?1049h"                                                 #* Switch to alternate screen
    1:         normal_screen           = "\033[?1049l"                                                 #* Switch to normal screen
    1:         clear                           = "\033[2J\033[0;0f"                                    #* Clear screen and set cursor to position 0,0
    1:         mouse_on                        = "\033[?1002h\033[?1015h\033[?1006h"   #* Enable reporting of mouse position on click and release
    1:         mouse_off                       = "\033[?1002l"                                                 #* Disable mouse reporting
    1:         mouse_direct_on         = "\033[?1003h"                                                 #* Enable reporting of mouse position at any movement
    1:         mouse_direct_off        = "\033[?1003l"                                                 #* Disable direct mouse reporting
    1:         winch = threading.Event()
    1:         old_boxes: List = []
    1:         min_width: int = 0
    1:         min_height: int = 0
       
    1:         @classmethod
    1:         def refresh(cls, *args, force: bool = False):
                       """Update width, height and set resized flag if terminal has been resized"""
    3:                 if Init.running: cls.resized = False; return
    3:                 if cls.resized: cls.winch.set(); return
    3:                 cls._w, cls._h = os.get_terminal_size()
    3:                 if (cls._w, cls._h) == (cls.width, cls.height) and cls.old_boxes == Box.boxes and not force: return
    1:                 if force: Collector.collect_interrupt = True
    1:                 if cls.old_boxes != Box.boxes:
    1:                         w_p = h_p = 0
    1:                         cls.min_width = cls.min_height = 0
    1:                         cls.old_boxes = Box.boxes.copy()
    5:                         for box_class in Box.__subclasses__():
   16:                                 for box_name in Box.boxes:
   12:                                         if box_name in str(box_class).capitalize():
    3:                                                 if not (box_name == "cpu" and "proc" in Box.boxes) and not (box_name == "net" and "mem" in Box.boxes) and w_p + box_class.width_p <= 100:
    1:                                                         w_p += box_class.width_p
    1:                                                         cls.min_width += getattr(box_class, "min_w", 0)
    3:                                                 if not (box_name in ["mem", "net"] and "proc" in Box.boxes) and h_p + box_class.height_p <= 100:
    3:                                                         h_p += box_class.height_p
    3:                                                         cls.min_height += getattr(box_class, "min_h", 0)
    1:                 while (cls._w, cls._h) != (cls.width, cls.height) or (cls._w < cls.min_width or cls._h < cls.min_height):
                               if Init.running: Init.resized = True
                               CpuBox.clock_block = True
                               cls.resized = True
                               Collector.collect_interrupt = True
                               cls.width, cls.height = cls._w, cls._h
                               Draw.now(Term.clear)
                               box_width = min(50, cls._w - 2)
                               Draw.now(f'{create_box(cls._w // 2 - box_width // 2, cls._h // 2 - 2, 50, 3, "resizing", line_color=Colors.green, title_color=Colors.white)}',
                                       f'{Mv.r(box_width // 4)}{Colors.default}{Colors.black_bg}{Fx.b}Width : {cls._w}   Height: {cls._h}{Fx.ub}{Term.bg}{Term.fg}')
                               if cls._w < 80 or cls._h < 24:
                                       while cls._w < cls.min_width or cls._h < cls.min_height:
                                               Draw.now(Term.clear)
                                               box_width = min(50, cls._w - 2)
                                               Draw.now(f'{create_box(cls._w // 2 - box_width // 2, cls._h // 2 - 2, box_width, 4, "warning", line_color=Colors.red, title_color=Colors.white)}',
                                                       f'{Mv.r(box_width // 4)}{Colors.default}{Colors.black_bg}{Fx.b}Width: {Colors.red if cls._w < cls.min_width else Colors.green}{cls._w}   ',
                                                       f'{Colors.default}Height: {Colors.red if cls._h < cls.min_height else Colors.green}{cls._h}{Term.bg}{Term.fg}',
                                                       f'{Mv.d(1)}{Mv.l(25)}{Colors.default}{Colors.black_bg}Current config need: {cls.min_width} x {cls.min_height}{Fx.ub}{Term.bg}{Term.fg}')
                                               cls.winch.wait(0.3)
                                               while Key.has_key():
                                                       if Key.last() == "q": clean_quit()
                                               cls.winch.clear()
                                               cls._w, cls._h = os.get_terminal_size()
                               else:
                                       cls.winch.wait(0.3)
                                       cls.winch.clear()
                               cls._w, cls._h = os.get_terminal_size()
       
    1:                 Key.mouse = {}
    1:                 Box.calc_sizes()
    1:                 Collector.proc_counter = 1
    1:                 if Menu.active: Menu.resized = True
    1:                 Box.draw_bg(now=False)
    1:                 cls.resized = False
    1:                 Timer.finish()
       
    1:         @staticmethod
    1:         def echo(on: bool):
                       """Toggle input echo"""
    2:                 (iflag, oflag, cflag, lflag, ispeed, ospeed, cc) = termios.tcgetattr(sys.stdin.fileno())
    2:                 if on:
    1:                         lflag |= termios.ECHO # type: ignore
                       else:
    1:                         lflag &= ~termios.ECHO # type: ignore
    2:                 new_attr = [iflag, oflag, cflag, lflag, ispeed, ospeed, cc]
    2:                 termios.tcsetattr(sys.stdin.fileno(), termios.TCSANOW, new_attr)
       
    1:         @staticmethod
    1:         def title(text: str = "") -> str:
    2:                 out: str = f'{os.environ.get("TERMINAL_TITLE", "")}'
    2:                 if out and text: out += " "
    2:                 if text: out += f'{text}'
    2:                 return f'\033]0;{out}\a'
       
    2: class Fx:
    1:         """Text effects
               * trans(string: str): Replace whitespace with escape move right to not overwrite background behind whitespace.
               * uncolor(string: str) : Removes all 24-bit color and returns string ."""
    1:         start                                   = "\033["                       #* Escape sequence start
    1:         sep                                             = ";"                           #* Escape sequence separator
    1:         end                                             = "m"                           #* Escape sequence end
    1:         reset = rs                              = "\033[0m"                     #* Reset foreground/background color and text effects
    1:         bold = b                                = "\033[1m"                     #* Bold on
    1:         unbold = ub                             = "\033[22m"            #* Bold off
    1:         dark = d                                = "\033[2m"                     #* Dark on
    1:         undark = ud                             = "\033[22m"            #* Dark off
    1:         italic = i                              = "\033[3m"                     #* Italic on
    1:         unitalic = ui                   = "\033[23m"            #* Italic off
    1:         underline = u                   = "\033[4m"                     #* Underline on
    1:         ununderline = uu                = "\033[24m"            #* Underline off
    1:         blink = bl                              = "\033[5m"                     #* Blink on
    1:         unblink = ubl                   = "\033[25m"            #* Blink off
    1:         strike = s                              = "\033[9m"                     #* Strike / crossed-out on
    1:         unstrike = us                   = "\033[29m"            #* Strike / crossed-out off
       
               #* Precompiled regex for finding a 24-bit color escape sequence in a string
    1:         color_re = re.compile(r"\033\[\d+;\d?;?\d*;?\d*;?\d*m")
       
    1:         @staticmethod
    1:         def trans(string: str):
   48:                 return string.replace(" ", "\033[1C")
       
    1:         @classmethod
    1:         def uncolor(cls, string: str) -> str:
                       return f'{cls.color_re.sub("", string)}'
       
    2: class Raw(object):
    1:         """Set raw input mode for device"""
    1:         def __init__(self, stream):
   14:                 self.stream = stream
   14:                 self.fd = self.stream.fileno()
    1:         def __enter__(self):
   14:                 self.original_stty = termios.tcgetattr(self.stream)
   14:                 tty.setcbreak(self.stream)
    1:         def __exit__(self, type, value, traceback):
   14:                 termios.tcsetattr(self.stream, termios.TCSANOW, self.original_stty)
       
    2: class Nonblocking(object):
    1:         """Set nonblocking mode for device"""
    1:         def __init__(self, stream):
                       self.stream = stream
                       self.fd = self.stream.fileno()
    1:         def __enter__(self):
                       self.orig_fl = fcntl.fcntl(self.fd, fcntl.F_GETFL)
                       fcntl.fcntl(self.fd, fcntl.F_SETFL, self.orig_fl | os.O_NONBLOCK)
    1:         def __exit__(self, *args):
                       fcntl.fcntl(self.fd, fcntl.F_SETFL, self.orig_fl)
       
    2: class Mv:
    1:         """Class with collection of cursor movement functions: .t[o](line, column) | .r[ight](columns) | .l[eft](columns) | .u[p](lines) | .d[own](lines) | .save() | .restore()"""
    1:         @staticmethod
    1:         def to(line: int, col: int) -> str:
  447:                 return f'\033[{line};{col}f'    #* Move cursor to line, column
    1:         @staticmethod
    1:         def right(x: int) -> str:                       #* Move cursor right x columns
   99:                 return f'\033[{x}C'
    1:         @staticmethod
    1:         def left(x: int) -> str:                        #* Move cursor left x columns
   58:                 return f'\033[{x}D'
    1:         @staticmethod
    1:         def up(x: int) -> str:                          #* Move cursor up x lines
                       return f'\033[{x}A'
    1:         @staticmethod
    1:         def down(x: int) -> str:                        #* Move cursor down x lines
   32:                 return f'\033[{x}B'
       
    1:         save: str = "\033[s"                            #* Save cursor position
    1:         restore: str = "\033[u"                         #* Restore saved cursor position
    1:         t = to
    1:         r = right
    1:         l = left
    1:         u = up
    1:         d = down
       
    2: class Key:
    1:         """Handles the threaded input reader for keypresses and mouse events"""
    1:         list: List[str] = []
    1:         mouse: Dict[str, List[List[int]]] = {}
    1:         mouse_pos: Tuple[int, int] = (0, 0)
    1:         escape: Dict[Union[str, Tuple[str, str]], str] = {
    1:                 "\n" :                                  "enter",
    1:                 ("\x7f", "\x08") :              "backspace",
    1:                 ("[A", "OA") :                  "up",
    1:                 ("[B", "OB") :                  "down",
    1:                 ("[D", "OD") :                  "left",
    1:                 ("[C", "OC") :                  "right",
    1:                 "[2~" :                                 "insert",
    1:                 "[3~" :                                 "delete",
    1:                 "[H" :                                  "home",
    1:                 "[F" :                                  "end",
    1:                 "[5~" :                                 "page_up",
    1:                 "[6~" :                                 "page_down",
    1:                 "\t" :                                  "tab",
    1:                 "[Z" :                                  "shift_tab",
    1:                 "OP" :                                  "f1",
    1:                 "OQ" :                                  "f2",
    1:                 "OR" :                                  "f3",
    1:                 "OS" :                                  "f4",
    1:                 "[15" :                                 "f5",
    1:                 "[17" :                                 "f6",
    1:                 "[18" :                                 "f7",
    1:                 "[19" :                                 "f8",
    1:                 "[20" :                                 "f9",
    1:                 "[21" :                                 "f10",
    1:                 "[23" :                                 "f11",
    1:                 "[24" :                                 "f12"
                       }
    1:         new = threading.Event()
    1:         idle = threading.Event()
    1:         mouse_move = threading.Event()
    1:         mouse_report: bool = False
    1:         idle.set()
    1:         stopping: bool = False
    1:         started: bool = False
    1:         reader: threading.Thread
    1:         @classmethod
    1:         def start(cls):
    1:                 cls.stopping = False
    1:                 cls.reader = threading.Thread(target=cls._get_key)
    1:                 cls.reader.start()
    1:                 cls.started = True
       
    1:         @classmethod
    1:         def stop(cls):
    1:                 if cls.started and cls.reader.is_alive():
    1:                         cls.stopping = True
    1:                         try:
    1:                                 cls.reader.join()
                               except:
                                       pass
       
    1:         @classmethod
    1:         def last(cls) -> str:
                       if cls.list: return cls.list.pop()
                       else: return ""
       
    1:         @classmethod
    1:         def get(cls) -> str:
    2:                 if cls.list: return cls.list.pop(0)
                       else: return ""
       
    1:         @classmethod
    1:         def get_mouse(cls) -> Tuple[int, int]:
                       if cls.new.is_set():
                               cls.new.clear()
                       return cls.mouse_pos
       
    1:         @classmethod
    1:         def mouse_moved(cls) -> bool:
                       if cls.mouse_move.is_set():
                               cls.mouse_move.clear()
                               return True
                       else:
                               return False
       
    1:         @classmethod
    1:         def has_key(cls) -> bool:
    3:                 return bool(cls.list)
       
    1:         @classmethod
    1:         def clear(cls):
                       cls.list = []
       
    1:         @classmethod
    1:         def input_wait(cls, sec: float = 0.0, mouse: bool = False) -> bool:
                       '''Returns True if key is detected else waits out timer and returns False'''
    2:                 if cls.list: return True
    1:                 if mouse: Draw.now(Term.mouse_direct_on)
    1:                 cls.new.wait(sec if sec > 0 else 0.0)
    1:                 if mouse: Draw.now(Term.mouse_direct_off, Term.mouse_on)
       
    1:                 if cls.new.is_set():
    1:                         cls.new.clear()
    1:                         return True
                       else:
                               return False
       
    1:         @classmethod
    1:         def break_wait(cls):
    1:                 cls.list.append("_null")
    1:                 cls.new.set()
    1:                 sleep(0.01)
    1:                 cls.new.clear()
       
    1:         @classmethod
    1:         def _get_key(cls):
                       """Get a key or escape sequence from stdin, convert to readable format and save to keys list. Meant to be run in it's own thread."""
    1:                 input_key: str = ""
    1:                 clean_key: str = ""
    1:                 try:
   15:                         while not cls.stopping:
   14:                                 with Raw(sys.stdin):
   14:                                         if not select([sys.stdin], [], [], 0.1)[0]:                     #* Wait 100ms for input on stdin then restart loop to check for stop flag
   13:                                                 continue
    1:                                         input_key += sys.stdin.read(1)                                          #* Read 1 key safely with blocking on
    1:                                         if input_key == "\033":                                                         #* If first character is a escape sequence keep reading
                                                       cls.idle.clear()                                                                #* Report IO block in progress to prevent Draw functions from getting a IO Block error
                                                       Draw.idle.wait()                                                                #* Wait for Draw function to finish if busy
                                                       with Nonblocking(sys.stdin):                                    #* Set non blocking to prevent read stall
                                                               input_key += sys.stdin.read(20)
                                                               if input_key.startswith("\033[<"):
                                                                       _ = sys.stdin.read(1000)
                                                       cls.idle.set()                                                                  #* Report IO blocking done
                                               #errlog.debug(f'{repr(input_key)}')
    1:                                         if input_key == "\033": clean_key = "escape"            #* Key is "escape" key if only containing \033
    1:                                         elif input_key.startswith(("\033[<0;", "\033[<35;", "\033[<64;", "\033[<65;")): #* Detected mouse event
                                                       try:
                                                               cls.mouse_pos = (int(input_key.split(";")[1]), int(input_key.split(";")[2].rstrip("mM")))
                                                       except:
                                                               pass
                                                       else:
                                                               if input_key.startswith("\033[<35;"):           #* Detected mouse move in mouse direct mode
                                                                       cls.mouse_move.set()
                                                                       cls.new.set()
                                                               elif input_key.startswith("\033[<64;"):         #* Detected mouse scroll up
                                                                       clean_key = "mouse_scroll_up"
                                                               elif input_key.startswith("\033[<65;"):         #* Detected mouse scroll down
                                                                       clean_key = "mouse_scroll_down"
                                                               elif input_key.startswith("\033[<0;") and input_key.endswith("m"): #* Detected mouse click release
                                                                       if Menu.active:
                                                                               clean_key = "mouse_click"
                                                                       else:
                                                                               for key_name, positions in cls.mouse.items(): #* Check if mouse position is clickable
                                                                                       if list(cls.mouse_pos) in positions:
                                                                                               clean_key = key_name
                                                                                               break
                                                                               else:
                                                                                       clean_key = "mouse_click"
    1:                                         elif input_key == "\\": clean_key = "\\"                        #* Clean up "\" to not return escaped
                                               else:
   27:                                                 for code in cls.escape.keys():                                  #* Go through dict of escape codes to get the cleaned key name
   26:                                                         if input_key.lstrip("\033").startswith(code):
                                                                       clean_key = cls.escape[code]
                                                                       break
                                                       else:                                                                                   #* If not found in escape dict and length of key is 1, assume regular character
    1:                                                         if len(input_key) == 1:
    1:                                                                 clean_key = input_key
    1:                                         if clean_key:
    1:                                                 cls.list.append(clean_key)                                              #* Store up to 10 keys in input queue for later processing
    1:                                                 if len(cls.list) > 10: del cls.list[0]
    1:                                                 clean_key = ""
    1:                                                 cls.new.set()                                                                   #* Set threading event to interrupt main thread sleep
    1:                                         input_key = ""
       
       
                       except Exception as e:
                               errlog.exception(f'Input thread failed with exception: {e}')
                               cls.idle.set()
                               cls.list.clear()
                               clean_quit(1, thread=True)
       
    2: class Draw:
    1:         '''Holds the draw buffer and manages IO blocking queue
               * .buffer([+]name[!], *args, append=False, now=False, z=100) : Add *args to buffer
               * - Adding "+" prefix to name sets append to True and appends to name's current string
               * - Adding "!" suffix to name sets now to True and print name's current string
               * .out(clear=False) : Print all strings in buffer, clear=True clear all buffers after
               * .now(*args) : Prints all arguments as a string
               * .clear(*names) : Clear named buffers, all if no argument
               * .last_screen() : Prints all saved buffers
               '''
    1:         strings: Dict[str, str] = {}
    1:         z_order: Dict[str, int] = {}
    1:         saved: Dict[str, str] = {}
    1:         save: Dict[str, bool] = {}
    1:         once: Dict[str, bool] = {}
    1:         idle = threading.Event()
    1:         idle.set()
       
    1:         @classmethod
    1:         def now(cls, *args):
                       '''Wait for input reader and self to be idle then print to screen'''
    9:                 Key.idle.wait()
    9:                 cls.idle.wait()
    9:                 cls.idle.clear()
    9:                 try:
    9:                         print(*args, sep="", end="", flush=True)
                       except BlockingIOError:
                               pass
                               Key.idle.wait()
                               print(*args, sep="", end="", flush=True)
    9:                 cls.idle.set()
       
    1:         @classmethod
    1:         def buffer(cls, name: str, *args: str, append: bool = False, now: bool = False, z: int = 100, only_save: bool = False, no_save: bool = False, once: bool = False):
   20:                 string: str = ""
   20:                 if name.startswith("+"):
                               name = name.lstrip("+")
                               append = True
   20:                 if name.endswith("!"):
                               name = name.rstrip("!")
                               now = True
   20:                 cls.save[name] = not no_save
   20:                 cls.once[name] = once
   20:                 if not name in cls.z_order or z != 100: cls.z_order[name] = z
   20:                 if args: string = "".join(args)
   20:                 if only_save:
    6:                         if name not in cls.saved or not append: cls.saved[name] = ""
    6:                         cls.saved[name] += string
                       else:
   14:                         if name not in cls.strings or not append: cls.strings[name] = ""
   14:                         cls.strings[name] += string
   14:                         if now:
    2:                                 cls.out(name)
       
    1:         @classmethod
    1:         def out(cls, *names: str, clear = False):
    6:                 out: str = ""
    6:                 if not cls.strings: return
    6:                 if names:
   44:                         for name in sorted(cls.z_order, key=cls.z_order.get, reverse=True): #type: ignore
   40:                                 if name in names and name in cls.strings:
    4:                                         out += cls.strings[name]
    4:                                         if cls.save[name]:
    4:                                                 cls.saved[name] = cls.strings[name]
    4:                                         if clear or cls.once[name]:
    2:                                                 cls.clear(name)
    4:                         cls.now(out)
                       else:
   20:                         for name in sorted(cls.z_order, key=cls.z_order.get, reverse=True): #type: ignore
   18:                                 if name in cls.strings:
   10:                                         out += cls.strings[name]
   10:                                         if cls.save[name]:
   10:                                                 cls.saved[name] = cls.strings[name]
   10:                                         if cls.once[name] and not clear:
                                                       cls.clear(name)
    2:                         if clear:
    1:                                 cls.clear()
    2:                         cls.now(out)
       
    1:         @classmethod
    1:         def saved_buffer(cls) -> str:
                       out: str = ""
                       for name in sorted(cls.z_order, key=cls.z_order.get, reverse=True): #type: ignore
                               if name in cls.saved:
                                       out += cls.saved[name]
                       return out
       
       
    1:         @classmethod
    1:         def clear(cls, *names, saved: bool = False):
    3:                 if names:
    4:                         for name in names:
    2:                                 if name in cls.strings:
    2:                                         del cls.strings[name]
    2:                                 if name in cls.save:
    2:                                         del cls.save[name]
    2:                                 if name in cls.once:
    2:                                         del cls.once[name]
    2:                                 if saved:
                                               if name in cls.saved:
                                                       del cls.saved[name]
                                               if name in cls.z_order:
                                                       del cls.z_order[name]
                       else:
    1:                         cls.strings = {}
    1:                         cls.save = {}
    1:                         cls.once = {}
    1:                         if saved:
                                       cls.saved = {}
                                       cls.z_order = {}
       
    2: class Color:
    1:         '''Holds representations for a 24-bit color value
               __init__(color, depth="fg", default=False)
               -- color accepts 6 digit hexadecimal: string "#RRGGBB", 2 digit hexadecimal: string "#FF" or decimal RGB "255 255 255" as a string.
               -- depth accepts "fg" or "bg"
               __call__(*args) joins str arguments to a string and apply color
               __str__ returns escape sequence to set color
               __iter__ returns iteration over red, green and blue in integer values of 0-255.
               * Values:  .hexa: str  |  .dec: Tuple[int, int, int]  |  .red: int  |  .green: int  |  .blue: int  |  .depth: str  |  .escape: str
               '''
    1:         hexa: str; dec: Tuple[int, int, int]; red: int; green: int; blue: int; depth: str; escape: str; default: bool
       
    1:         def __init__(self, color: str, depth: str = "fg", default: bool = False):
   50:                 self.depth = depth
   50:                 self.default = default
   50:                 try:
   50:                         if not color:
    1:                                 self.dec = (-1, -1, -1)
    1:                                 self.hexa = ""
    1:                                 self.red = self.green = self.blue = -1
    1:                                 self.escape = "\033[49m" if depth == "bg" and default else ""
    1:                                 return
       
   49:                         elif color.startswith("#"):
   49:                                 self.hexa = color
   49:                                 if len(self.hexa) == 3:
   11:                                         self.hexa += self.hexa[1:3] + self.hexa[1:3]
   11:                                         c = int(self.hexa[1:3], base=16)
   11:                                         self.dec = (c, c, c)
   38:                                 elif len(self.hexa) == 7:
   38:                                         self.dec = (int(self.hexa[1:3], base=16), int(self.hexa[3:5], base=16), int(self.hexa[5:7], base=16))
                                       else:
                                               raise ValueError(f'Incorrectly formatted hexadecimal rgb string: {self.hexa}')
       
                               else:
                                       c_t = tuple(map(int, color.split(" ")))
                                       if len(c_t) == 3:
                                               self.dec = c_t #type: ignore
                                       else:
                                               raise ValueError(f'RGB dec should be "0-255 0-255 0-255"')
       
  245:                         if not all(0 <= c <= 255 for c in self.dec):
                                       raise ValueError(f'One or more RGB values are out of range: {color}')
       
                       except Exception as e:
                               errlog.exception(str(e))
                               self.escape = ""
                               return
       
   49:                 if self.dec and not self.hexa: self.hexa = f'{hex(self.dec[0]).lstrip("0x").zfill(2)}{hex(self.dec[1]).lstrip("0x").zfill(2)}{hex(self.dec[2]).lstrip("0x").zfill(2)}'
       
   49:                 if self.dec and self.hexa:
   49:                         self.red, self.green, self.blue = self.dec
  245:                         self.escape = f'\033[{38 if self.depth == "fg" else 48};2;{";".join(str(c) for c in self.dec)}m'
       
   49:                 if not CONFIG.truecolor or LOW_COLOR:
                               self.escape = f'{self.truecolor_to_256(rgb=self.dec, depth=self.depth)}'
       
    1:         def __str__(self) -> str:
  181:                 return self.escape
       
    1:         def __repr__(self) -> str:
                       return repr(self.escape)
       
    1:         def __iter__(self) -> Iterable:
   44:                 for c in self.dec: yield c
       
    1:         def __call__(self, *args: str) -> str:
  170:                 if len(args) < 1: return ""
  170:                 return f'{self.escape}{"".join(args)}{getattr(Term, self.depth)}'
       
    1:         @staticmethod
    1:         def truecolor_to_256(rgb: Tuple[int, int, int], depth: str="fg") -> str:
                       out: str = ""
                       pre: str = f'\033[{"38" if depth == "fg" else "48"};5;'
       
                       greyscale: Tuple[int, int, int] = ( rgb[0] // 11, rgb[1] // 11, rgb[2] // 11 )
                       if greyscale[0] == greyscale[1] == greyscale[2]:
                               out = f'{pre}{232 + greyscale[0]}m'
                       else:
                               out = f'{pre}{round(rgb[0] / 51) * 36 + round(rgb[1] / 51) * 6 + round(rgb[2] / 51) + 16}m'
       
                       return out
       
    1:         @staticmethod
    1:         def escape_color(hexa: str = "", r: int = 0, g: int = 0, b: int = 0, depth: str = "fg") -> str:
                       """Returns escape sequence to set color
                       * accepts either 6 digit hexadecimal hexa="#RRGGBB", 2 digit hexadecimal: hexa="#FF"
                       * or decimal RGB: r=0-255, g=0-255, b=0-255
                       * depth="fg" or "bg"
                       """
 1151:                 dint: int = 38 if depth == "fg" else 48
 1151:                 color: str = ""
 1151:                 if hexa:
   40:                         try:
   40:                                 if len(hexa) == 3:
    8:                                         c = int(hexa[1:], base=16)
    8:                                         if CONFIG.truecolor and not LOW_COLOR:
    8:                                                 color = f'\033[{dint};2;{c};{c};{c}m'
                                               else:
                                                       color = f'{Color.truecolor_to_256(rgb=(c, c, c), depth=depth)}'
   32:                                 elif len(hexa) == 7:
   32:                                         if CONFIG.truecolor and not LOW_COLOR:
   32:                                                 color = f'\033[{dint};2;{int(hexa[1:3], base=16)};{int(hexa[3:5], base=16)};{int(hexa[5:7], base=16)}m'
                                               else:
                                                       color = f'{Color.truecolor_to_256(rgb=(int(hexa[1:3], base=16), int(hexa[3:5], base=16), int(hexa[5:7], base=16)), depth=depth)}'
                               except ValueError as e:
                                       errlog.exception(f'{e}')
                       else:
 1111:                         if CONFIG.truecolor and not LOW_COLOR:
 1111:                                 color = f'\033[{dint};2;{r};{g};{b}m'
                               else:
                                       color = f'{Color.truecolor_to_256(rgb=(r, g, b), depth=depth)}'
 1151:                 return color
       
    1:         @classmethod
    1:         def fg(cls, *args) -> str:
 1151:                 if len(args) > 2: return cls.escape_color(r=args[0], g=args[1], b=args[2], depth="fg")
   40:                 else: return cls.escape_color(hexa=args[0], depth="fg")
       
    1:         @classmethod
    1:         def bg(cls, *args) -> str:
                       if len(args) > 2: return cls.escape_color(r=args[0], g=args[1], b=args[2], depth="bg")
                       else: return cls.escape_color(hexa=args[0], depth="bg")
       
    2: class Colors:
    1:         '''Standard colors for menus and dialogs'''
    1:         default = Color("#cc")
    1:         white = Color("#ff")
    1:         red = Color("#bf3636")
    1:         green = Color("#68bf36")
    1:         blue = Color("#0fd7ff")
    1:         yellow = Color("#db8b00")
    1:         black_bg = Color("#00", depth="bg")
    1:         null = Color("")
       
    2: class Theme:
    1:         '''__init__ accepts a dict containing { "color_element" : "color" }'''
       
    1:         themes: Dict[str, str] = {}
    1:         cached: Dict[str, Dict[str, str]] = { "Default" : DEFAULT_THEME }
    1:         current: str = ""
       
    1:         main_bg = main_fg = title = hi_fg = selected_bg = selected_fg = inactive_fg = proc_misc = cpu_box = mem_box = net_box = proc_box = div_line = temp_start = temp_mid = temp_end = cpu_start = cpu_mid = cpu_end = free_start = free_mid = free_end = cached_start = cached_mid = cached_end = available_start = available_mid = available_end = used_start = used_mid = used_end = download_start = download_mid = download_end = upload_start = upload_mid = upload_end = graph_text = meter_bg = process_start = process_mid = process_end = Colors.default
       
    1:         gradient: Dict[str, List[str]] = {
    1:                 "temp" : [],
    1:                 "cpu" : [],
    1:                 "free" : [],
    1:                 "cached" : [],
    1:                 "available" : [],
    1:                 "used" : [],
    1:                 "download" : [],
    1:                 "upload" : [],
    1:                 "proc" : [],
    1:                 "proc_color" : [],
    1:                 "process" : [],
               }
    1:         def __init__(self, theme: str):
    1:                 self.refresh()
    1:                 self._load_theme(theme)
       
    1:         def __call__(self, theme: str):
                       for k in self.gradient.keys(): self.gradient[k] = []
                       self._load_theme(theme)
       
    1:         def _load_theme(self, theme: str):
                       tdict: Dict[str, str]
    1:                 if theme in self.cached:
    1:                         tdict = self.cached[theme]
                       elif theme in self.themes:
                               tdict = self._load_file(self.themes[theme])
                               self.cached[theme] = tdict
                       else:
                               errlog.warning(f'No theme named "{theme}" found!')
                               theme = "Default"
                               CONFIG.color_theme = theme
                               tdict = DEFAULT_THEME
    1:                 self.current = theme
                       #if CONFIG.color_theme != theme: CONFIG.color_theme = theme
    1:                 if not "graph_text" in tdict and "inactive_fg" in tdict:
                               tdict["graph_text"] = tdict["inactive_fg"]
    1:                 if not "meter_bg" in tdict and "inactive_fg" in tdict:
                               tdict["meter_bg"] = tdict["inactive_fg"]
    1:                 if not "process_start" in tdict and "cpu_start" in tdict:
                               tdict["process_start"] = tdict["cpu_start"]
                               tdict["process_mid"] = tdict.get("cpu_mid", "")
                               tdict["process_end"] = tdict.get("cpu_end", "")
       
       
                       #* Get key names from DEFAULT_THEME dict to not leave any color unset if missing from theme dict
   43:                 for item, value in DEFAULT_THEME.items():
   42:                         default = item in ["main_fg", "main_bg"]
   42:                         depth = "bg" if item in ["main_bg", "selected_bg"] else "fg"
   42:                         if item in tdict:
   42:                                 setattr(self, item, Color(tdict[item], depth=depth, default=default))
                               else:
                                       setattr(self, item, Color(value, depth=depth, default=default))
       
                       #* Create color gradients from one, two or three colors, 101 values indexed 0-100
    1:                 self.proc_start, self.proc_mid, self.proc_end = self.main_fg, Colors.null, self.inactive_fg
    1:                 self.proc_color_start, self.proc_color_mid, self.proc_color_end = self.inactive_fg, Colors.null, self.process_start
       
                       rgb: Dict[str, Tuple[int, int, int]]
    1:                 colors: List[List[int]] = []
   12:                 for name in self.gradient:
   11:                         rgb = { "start" : getattr(self, f'{name}_start').dec, "mid" : getattr(self, f'{name}_mid').dec, "end" : getattr(self, f'{name}_end').dec }
   11:                         colors = [ list(getattr(self, f'{name}_start')) ]
   11:                         if rgb["end"][0] >= 0:
   11:                                 r = 50 if rgb["mid"][0] >= 0 else 100
   29:                                 for first, second in ["start", "mid" if r == 50 else "end"], ["mid", "end"]:
 1120:                                         for i in range(r):
 5500:                                                 colors += [[rgb[first][n] + i * (rgb[second][n] - rgb[first][n]) // r for n in range(3)]]
   20:                                         if r == 100:
    2:                                                 break
 1133:                                 self.gradient[name] += [ Color.fg(*color) for color in colors ]
       
                               else:
                                       c = Color.fg(*rgb["start"])
                                       self.gradient[name] += [c] * 101
                       #* Set terminal colors
    1:                 Term.fg = f'{self.main_fg}'
    1:                 Term.bg = f'{self.main_bg}' if CONFIG.theme_background else "\033[49m"
    1:                 Draw.now(self.main_fg, self.main_bg)
       
    1:         @classmethod
    1:         def refresh(cls):
                       '''Sets themes dict with names and paths to all found themes'''
    1:                 cls.themes = { "Default" : "Default" }
    1:                 try:
    3:                         for d in (THEME_DIR, USER_THEME_DIR):
    2:                                 if not d: continue
    1:                                 for f in os.listdir(d):
                                               if f.endswith(".theme"):
                                                       cls.themes[f'{"" if d == THEME_DIR else "+"}{f[:-6]}'] = f'{d}/{f}'
                       except Exception as e:
                               errlog.exception(str(e))
       
    1:         @staticmethod
    1:         def _load_file(path: str) -> Dict[str, str]:
                       '''Load a bashtop formatted theme file and return a dict'''
                       new_theme: Dict[str, str] = {}
                       try:
                               with open(path, "r") as f:
                                       for line in f:
                                               if not line.startswith("theme["): continue
                                               key = line[6:line.find("]")]
                                               s = line.find('"')
                                               value = line[s + 1:line.find('"', s + 1)]
                                               new_theme[key] = value
                       except Exception as e:
                               errlog.exception(str(e))
       
                       return new_theme
       
    2: class Banner:
    1:         '''Holds the bpytop banner, .draw(line, [col=0], [center=False], [now=False])'''
    1:         out: List[str] = []
    1:         c_color: str = ""
    1:         length: int = 0
    1:         if not out:
    7:                 for num, (color, color2, line) in enumerate(BANNER_SRC):
    6:                         if len(line) > length: length = len(line)
    6:                         out_var = ""
    6:                         line_color = Color.fg(color)
    6:                         line_color2 = Color.fg(color2)
    6:                         line_dark = Color.fg(f'#{80 - num * 6}')
  301:                         for n, letter in enumerate(line):
  295:                                 if letter == "█" and c_color != line_color:
   62:                                         if 5 < n < 25: c_color = line_color2
   26:                                         else: c_color = line_color
   62:                                         out_var += c_color
  233:                                 elif letter == " ":
   71:                                         letter = f'{Mv.r(1)}'
   71:                                         c_color = ""
  162:                                 elif letter != "█" and c_color != line_dark:
   48:                                         c_color = line_dark
   48:                                         out_var += line_dark
  295:                                 out_var += letter
    6:                         out.append(out_var)
       
    1:         @classmethod
    1:         def draw(cls, line: int, col: int = 0, center: bool = False, now: bool = False):
                       out: str = ""
                       if center: col = Term.width // 2 - cls.length // 2
                       for n, o in enumerate(cls.out):
                               out += f'{Mv.to(line + n, col)}{o}'
                       out += f'{Term.fg}'
                       if now: Draw.out(out)
                       else: return out
       
    2: class Symbol:
    1:         h_line: str                     = "─"
    1:         v_line: str                     = "│"
    1:         left_up: str            = "┌"
    1:         right_up: str           = "┐"
    1:         left_down: str          = "└"
    1:         right_down: str         = "┘"
    1:         title_left: str         = "┤"
    1:         title_right: str        = "├"
    1:         div_up: str                     = "┬"
    1:         div_down: str           = "┴"
    1:         graph_up: Dict[float, str] = {
    1:         0.0 : " ", 0.1 : "⢀", 0.2 : "⢠", 0.3 : "⢰", 0.4 : "⢸",
    1:         1.0 : "⡀", 1.1 : "⣀", 1.2 : "⣠", 1.3 : "⣰", 1.4 : "⣸",
    1:         2.0 : "⡄", 2.1 : "⣄", 2.2 : "⣤", 2.3 : "⣴", 2.4 : "⣼",
    1:         3.0 : "⡆", 3.1 : "⣆", 3.2 : "⣦", 3.3 : "⣶", 3.4 : "⣾",
    1:         4.0 : "⡇", 4.1 : "⣇", 4.2 : "⣧", 4.3 : "⣷", 4.4 : "⣿"
               }
    1:         graph_up_small = graph_up.copy()
    1:         graph_up_small[0.0] = "\033[1C"
       
    1:         graph_down: Dict[float, str] = {
    1:         0.0 : " ", 0.1 : "⠈", 0.2 : "⠘", 0.3 : "⠸", 0.4 : "⢸",
    1:         1.0 : "⠁", 1.1 : "⠉", 1.2 : "⠙", 1.3 : "⠹", 1.4 : "⢹",
    1:         2.0 : "⠃", 2.1 : "⠋", 2.2 : "⠛", 2.3 : "⠻", 2.4 : "⢻",
    1:         3.0 : "⠇", 3.1 : "⠏", 3.2 : "⠟", 3.3 : "⠿", 3.4 : "⢿",
    1:         4.0 : "⡇", 4.1 : "⡏", 4.2 : "⡟", 4.3 : "⡿", 4.4 : "⣿"
               }
    1:         graph_down_small = graph_down.copy()
    1:         graph_down_small[0.0] = "\033[1C"
    1:         meter: str = "■"
    1:         up: str = "↑"
    1:         down: str = "↓"
    1:         left: str = "←"
    1:         right: str = "→"
    1:         enter: str = "↲"
    1:         ok: str = f'{Color.fg("#30ff50")}√{Color.fg("#cc")}'
    1:         fail: str = f'{Color.fg("#ff3050")}!{Color.fg("#cc")}'
       
    2: class Graph:
    1:         '''Class for creating and adding to graphs
               * __str__ : returns graph as a string
               * add(value: int) : adds a value to graph and returns it as a string
               * __call__ : same as add
               '''
    1:         out: str
    1:         width: int
    1:         height: int
    1:         graphs: Dict[bool, List[str]]
    1:         colors: List[str]
    1:         invert: bool
    1:         max_value: int
    1:         color_max_value: int
    1:         offset: int
    1:         no_zero: bool
    1:         round_up_low: bool
    1:         current: bool
    1:         last: int
    1:         lowest: int = 0
    1:         symbol: Dict[float, str]
       
    1:         def __init__(self, width: int, height: int, color: Union[List[str], Color, None], data: List[int], invert: bool = False, max_value: int = 0, offset: int = 0, color_max_value: Union[int, None] = None, no_zero: bool = False, round_up_low: bool = False):
   41:                 self.graphs: Dict[bool, List[str]] = {False : [], True : []}
   41:                 self.current: bool = True
   41:                 self.width = width
   41:                 self.height = height
   41:                 self.invert = invert
   41:                 self.offset = offset
   41:                 self.round_up_low = round_up_low
   41:                 self.no_zero = no_zero or round_up_low
   41:                 if not data: data = [0]
   41:                 if max_value:
   13:                         self.lowest = 1 if self.round_up_low else 0
   13:                         self.max_value = max_value
   42:                         data = [ min_max((v + offset) * 100 // (max_value + offset), min_max(v + offset, 0, self.lowest), 100) for v in data ] #* Convert values to percentage values of max_value with max_value as ceiling
                       else:
   28:                         self.max_value = 0
   41:                 if color_max_value:
                               self.color_max_value = color_max_value
                       else:
   41:                         self.color_max_value = self.max_value
   41:                 if self.color_max_value and self.max_value:
   13:                         color_scale = int(100.0 * self.max_value / self.color_max_value)
                       else:
   28:                         color_scale = 100
   41:                 self.colors: List[str] = []
   41:                 if isinstance(color, list) and height > 1:
   36:                         for i in range(1, height + 1): self.colors.insert(0, color[min(100, i * color_scale // height)]) #* Calculate colors of graph
    8:                         if invert: self.colors.reverse()
   33:                 elif isinstance(color, Color) and height > 1:
                               self.colors = [ f'{color}' for _ in range(height) ]
                       else:
   33:                         if isinstance(color, list): self.colors = color
   18:                         elif isinstance(color, Color): self.colors = [ f'{color}' for _ in range(101) ]
   41:                 if self.height == 1:
   33:                         self.symbol = Symbol.graph_down_small if invert else Symbol.graph_up_small
                       else:
    8:                         self.symbol = Symbol.graph_down if invert else Symbol.graph_up
   41:                 value_width: int = ceil(len(data) / 2)
   41:                 filler: str = ""
   41:                 if value_width > width: #* If the size of given data set is bigger then width of graph, shrink data set
                               data = data[-(width*2):]
                               value_width = ceil(len(data) / 2)
   41:                 elif value_width < width: #* If the size of given data set is smaller then width of graph, fill graph with whitespace
   41:                         filler = self.symbol[0.0] * (width - value_width)
   41:                 if len(data) % 2: data.insert(0, 0)
  102:                 for _ in range(height):
  183:                         for b in [True, False]:
  122:                                 self.graphs[b].append(filler)
   41:                 self._create(data, new=True)
       
    1:         def _create(self, data: List[int], new: bool = False):
                       h_high: int
                       h_low: int
   41:                 value: Dict[str, int] = { "left" : 0, "right" : 0 }
                       val: int
                       side: str
       
                       #* Create the graph
  102:                 for h in range(self.height):
   61:                         h_high = round(100 * (self.height - h) / self.height) if self.height > 1 else 100
   61:                         h_low = round(100 * (self.height - (h + 1)) / self.height) if self.height > 1 else 0
  223:                         for v in range(len(data)):
  162:                                 if new: self.current = bool(v % 2) #* Switch between True and False graphs
  162:                                 if new and v == 0: self.last = 0
  486:                                 for val, side in [self.last, "left"], [data[v], "right"]: # type: ignore
  324:                                         if val >= h_high:
   20:                                                 value[side] = 4
  304:                                         elif val <= h_low:
  258:                                                 value[side] = 0
                                               else:
   46:                                                 if self.height == 1: value[side] = round(val * 4 / 100 + 0.5)
    6:                                                 else: value[side] = round((val - h_low) * 4 / (h_high - h_low) + 0.1)
  324:                                         if self.no_zero and not (new and v == 0 and side == "left") and h == self.height - 1 and value[side] < 1 and not (self.round_up_low and val == 0): value[side] = 1
  162:                                 if new: self.last = data[v]
  162:                                 self.graphs[self.current][h] += self.symbol[float(value["left"] + value["right"] / 10)]
   41:                 if data: self.last = data[-1]
   41:                 self.out = ""
       
   41:                 if self.height == 1:
   33:                         self.out += f'{"" if not self.colors else (THEME.inactive_fg if self.last < 5 else self.colors[self.last])}{self.graphs[self.current][0]}'
    8:                 elif self.height > 1:
   36:                         for h in range(self.height):
   28:                                 if h > 0: self.out += f'{Mv.d(1)}{Mv.l(self.width)}'
   28:                                 self.out += f'{"" if not self.colors else self.colors[h]}{self.graphs[self.current][h if not self.invert else (self.height - 1) - h]}'
   41:                 if self.colors: self.out += f'{Term.fg}'
       
    1:         def __call__(self, value: Union[int, None] = None) -> str:
   37:                 if not isinstance(value, int): return self.out
                       self.current = not self.current
                       if self.height == 1:
                               if self.graphs[self.current][0].startswith(self.symbol[0.0]):
                                       self.graphs[self.current][0] = self.graphs[self.current][0].replace(self.symbol[0.0], "", 1)
                               else:
                                       self.graphs[self.current][0] = self.graphs[self.current][0][1:]
                       else:
                               for n in range(self.height):
                                       self.graphs[self.current][n] = self.graphs[self.current][n][1:]
                       if self.max_value: value = min_max((value + self.offset) * 100 // (self.max_value + self.offset), min_max(value + self.offset, 0, self.lowest), 100)
                       self._create([value])
                       return self.out
       
    1:         def add(self, value: Union[int, None] = None) -> str:
                       return self.__call__(value)
       
    1:         def __str__(self):
                       return self.out
       
    1:         def __repr__(self):
                       return repr(self.out)
       
       
    2: class Graphs:
    1:         '''Holds all graphs and lists of graphs for dynamically created graphs'''
    1:         cpu: Dict[str, Graph] = {}
    1:         cores: List[Graph] = [NotImplemented] * THREADS
    1:         temps: List[Graph] = [NotImplemented] * (THREADS + 1)
    1:         net: Dict[str, Graph] = {}
    1:         detailed_cpu: Graph = NotImplemented
    1:         detailed_mem: Graph = NotImplemented
    1:         pid_cpu: Dict[int, Graph] = {}
    1:         disk_io: Dict[str, Dict[str, Graph]] = {}
       
    2: class Meter:
    1:         '''Creates a percentage meter
               __init__(value, width, theme, gradient_name) to create new meter
               __call__(value) to set value and return meter as a string
               __str__ returns last set meter as a string
               '''
    1:         out: str
    1:         color_gradient: List[str]
    1:         color_inactive: Color
    1:         gradient_name: str
    1:         width: int
    1:         invert: bool
    1:         saved: Dict[int, str]
       
    1:         def __init__(self, value: int, width: int, gradient_name: str, invert: bool = False):
   16:                 self.gradient_name = gradient_name
   16:                 self.color_gradient = THEME.gradient[gradient_name]
   16:                 self.color_inactive = THEME.meter_bg
   16:                 self.width = width
   16:                 self.saved = {}
   16:                 self.invert = invert
   16:                 self.out = self._create(value)
       
    1:         def __call__(self, value: Union[int, None]) -> str:
   13:                 if not isinstance(value, int): return self.out
    4:                 if value > 100: value = 100
    4:                 elif value < 0: value = 100
    4:                 if value in self.saved:
    4:                         self.out = self.saved[value]
                       else:
                               self.out = self._create(value)
    4:                 return self.out
       
    1:         def __str__(self) -> str:
                       return self.out
       
    1:         def __repr__(self):
                       return repr(self.out)
       
    1:         def _create(self, value: int) -> str:
   16:                 if value > 100: value = 100
   16:                 elif value < 0: value = 100
   16:                 out: str = ""
  331:                 for i in range(1, self.width + 1):
  329:                         if value >= round(i * 100 / self.width):
  315:                                 out += f'{self.color_gradient[round(i * 100 / self.width) if not self.invert else round(100 - (i * 100 / self.width))]}{Symbol.meter}'
                               else:
   14:                                 out += self.color_inactive(Symbol.meter * (self.width + 1 - i))
   14:                                 break
                       else:
    2:                         out += f'{Term.fg}'
   16:                 if not value in self.saved:
   16:                         self.saved[value] = out
   16:                 return out
       
    2: class Meters:
    1:         cpu: Meter
    1:         battery: Meter
    1:         mem: Dict[str, Union[Meter, Graph]] = {}
    1:         swap: Dict[str, Union[Meter, Graph]] = {}
    1:         disks_used: Dict[str, Meter] = {}
    1:         disks_free: Dict[str, Meter] = {}
       
    2: class Box:
    1:         '''Box class with all needed attributes for create_box() function'''
    1:         name: str
    1:         num: int = 0
    1:         boxes: List = []
    1:         view_modes: Dict[str, List] = {"full" : ["cpu", "mem", "net", "proc"], "stat" : ["cpu", "mem", "net"], "proc" : ["cpu", "proc"]}
    1:         view_mode: str
    2:         for view_mode in view_modes:
    2:                 if sorted(CONFIG.shown_boxes.split(), key=str.lower) == view_modes[view_mode]:
    1:                         break
               else:
                       view_mode = "user"
                       view_modes["user"] = CONFIG.shown_boxes.split()
    1:         height_p: int
    1:         width_p: int
    1:         x: int
    1:         y: int
    1:         width: int
    1:         height: int
    1:         out: str
    1:         bg: str
    1:         _b_cpu_h: int
    1:         _b_mem_h: int
    1:         redraw_all: bool
    1:         buffers: List[str] = []
    1:         c_counter: int = 0
    1:         clock_on: bool = False
    1:         clock: str = ""
    1:         clock_len: int = 0
    1:         resized: bool = False
    1:         clock_custom_format: Dict[str, Any] = {
    1:                 "/host" : os.uname()[1],
    1:                 "/user" : os.environ.get("USER") or pwd.getpwuid(os.getuid())[0],
    1:                 "/uptime" : "",
                       }
    1:         if clock_custom_format["/host"].endswith(".local"):
    1:                 clock_custom_format["/host"] = clock_custom_format["/host"].replace(".local", "")
       
    1:         @classmethod
    1:         def calc_sizes(cls):
                       '''Calculate sizes of boxes'''
    2:                 cls.boxes = CONFIG.shown_boxes.split()
   10:                 for sub in cls.__subclasses__():
    8:                         sub._calc_size() # type: ignore
    8:                         sub.resized = True # type: ignore
       
    1:         @classmethod
    1:         def draw_update_ms(cls, now: bool = True):
    2:                 if not "cpu" in cls.boxes: return
    2:                 update_string: str = f'{CONFIG.update_ms}ms'
    2:                 xpos: int = CpuBox.x + CpuBox.width - len(update_string) - 15
    2:                 if not "+" in Key.mouse:
   10:                         Key.mouse["+"] = [[xpos + 7 + i, CpuBox.y] for i in range(3)]
   10:                         Key.mouse["-"] = [[CpuBox.x + CpuBox.width - 4 + i, CpuBox.y] for i in range(3)]
    4:                 Draw.buffer("update_ms!" if now and not Menu.active else "update_ms",
    2:                         f'{Mv.to(CpuBox.y, xpos)}{THEME.cpu_box(Symbol.h_line * 7, Symbol.title_left)}{Fx.b}{THEME.hi_fg("+")} ',
    2:                         f'{THEME.title(update_string)} {THEME.hi_fg("-")}{Fx.ub}{THEME.cpu_box(Symbol.title_right)}', only_save=Menu.active, once=True)
    2:                 if now and not Menu.active:
                               Draw.clear("update_ms")
                               if CONFIG.show_battery and hasattr(psutil, "sensors_battery") and psutil.sensors_battery():
                                       Draw.out("battery")
       
    1:         @classmethod
    1:         def draw_clock(cls, force: bool = False):
   16:                 if not "cpu" in cls.boxes or not cls.clock_on: return
   12:                 cls.c_counter += 1
   12:                 if cls.c_counter > 3600 / (Config.update_ms / 1000):
                               tzset()
                               cls.c_counter = 0
   12:                 out: str = ""
   12:                 if force: pass
   12:                 elif Term.resized or strftime(CONFIG.draw_clock) == cls.clock: return
    2:                 clock_string = cls.clock = strftime(CONFIG.draw_clock)
    8:                 for custom in cls.clock_custom_format:
    6:                         if custom in clock_string:
                                       if custom == "/uptime": cls.clock_custom_format["/uptime"] = CpuCollector.uptime
                                       clock_string = clock_string.replace(custom, cls.clock_custom_format[custom])
    2:                 clock_len = len(clock_string[:(CpuBox.width-56)])
    2:                 if cls.clock_len != clock_len and not CpuBox.resized:
    1:                         out = f'{Mv.to(CpuBox.y, ((CpuBox.width)//2)-(cls.clock_len//2))}{Fx.ub}{THEME.cpu_box}{Symbol.h_line * cls.clock_len}'
    2:                 cls.clock_len = clock_len
    2:                 now: bool = False if Menu.active else not force
    2:                 out += (f'{Mv.to(CpuBox.y, ((CpuBox.width)//2)-(clock_len//2))}{Fx.ub}{THEME.cpu_box}'
                               f'{Symbol.title_left}{Fx.b}{THEME.title(clock_string[:clock_len])}{Fx.ub}{THEME.cpu_box}{Symbol.title_right}{Term.fg}')
    2:                 Draw.buffer("clock", out, z=1, now=now, once=not force, only_save=Menu.active)
    2:                 if now and not Menu.active:
    2:                         if CONFIG.show_battery and hasattr(psutil, "sensors_battery") and psutil.sensors_battery():
    2:                                 Draw.out("battery")
       
    1:         @classmethod
    1:         def empty_bg(cls) -> str:
                       return (f'{Term.clear}' +
                                       (f'{Banner.draw(Term.height // 2 - 10, center=True)}'
                                       f'{Mv.d(1)}{Mv.l(46)}{Colors.black_bg}{Colors.default}{Fx.b}[esc] Menu'
                                       f'{Mv.r(25)}{Fx.i}Version: {VERSION}{Fx.ui}' if Term.height > 22 else "") +
                                       f'{Mv.d(1)}{Mv.l(34)}{Fx.b}All boxes hidden!'
                                       f'{Mv.d(1)}{Mv.l(17)}{Fx.b}[1] {Fx.ub}Toggle CPU box'
                                       f'{Mv.d(1)}{Mv.l(18)}{Fx.b}[2] {Fx.ub}Toggle MEM box'
                                       f'{Mv.d(1)}{Mv.l(18)}{Fx.b}[3] {Fx.ub}Toggle NET box'
                                       f'{Mv.d(1)}{Mv.l(18)}{Fx.b}[4] {Fx.ub}Toggle PROC box'
                                       f'{Mv.d(1)}{Mv.l(19)}{Fx.b}[m] {Fx.ub}Cycle presets'
                                       f'{Mv.d(1)}{Mv.l(17)}{Fx.b}[q] Quit {Fx.ub}{Term.bg}{Term.fg}')
       
    1:         @classmethod
    1:         def draw_bg(cls, now: bool = True):
                       '''Draw all boxes outlines and titles'''
    2:                 out: str = ""
    2:                 if not cls.boxes:
                               out = cls.empty_bg()
                       else:
   12:                         out = "".join(sub._draw_bg() for sub in cls.__subclasses__()) # type: ignore
    2:                 Draw.buffer("bg", out, now=now, z=1000, only_save=Menu.active, once=True)
    2:                 cls.draw_update_ms(now=now)
    2:                 if CONFIG.draw_clock: cls.draw_clock(force=True)
       
    2: class SubBox:
    1:         box_x: int = 0
    1:         box_y: int = 0
    1:         box_width: int = 0
    1:         box_height: int = 0
    1:         box_columns: int = 0
    1:         column_size: int = 0
       
    2: class CpuBox(Box, SubBox):
    1:         name = "cpu"
    1:         num = 1
    1:         x = 1
    1:         y = 1
    1:         height_p = 32
    1:         width_p = 100
    1:         min_w: int = 60
    1:         min_h: int = 8
    1:         resized: bool = True
    1:         redraw: bool = False
    1:         buffer: str = "cpu"
    1:         battery_percent: int = 1000
    1:         battery_secs: int = 0
    1:         battery_status: str = "Unknown"
    1:         old_battery_pos = 0
    1:         old_battery_len = 0
    1:         battery_path: Union[str, None] = ""
    1:         battery_clear: bool = False
    2:         battery_symbols: Dict[str, str] = {"Charging": "▲",
    1:                                                                         "Discharging": "▼",
    1:                                                                         "Full": "■",
    1:                                                                         "Not charging": "■"}
    1:         clock_block: bool = True
    1:         Box.buffers.append(buffer)
       
    1:         @classmethod
    1:         def _calc_size(cls):
    2:                 if not "cpu" in cls.boxes:
                               Box._b_cpu_h = 0
                               cls.width = Term.width
                               return
    2:                 cpu = CpuCollector
                       height_p: int
    2:                 if cls.boxes == ["cpu"]:
                               height_p = 100
                       else:
    2:                         height_p = cls.height_p
    2:                 cls.width = round(Term.width * cls.width_p / 100)
    2:                 cls.height = round(Term.height * height_p / 100)
    2:                 if cls.height < 8: cls.height = 8
    2:                 Box._b_cpu_h = cls.height
                       #THREADS = 64
    2:                 cls.box_columns = ceil((THREADS + 1) / (cls.height - 5))
    2:                 if cls.box_columns * (20 + 13 if cpu.got_sensors else 21) < cls.width - (cls.width // 3):
    2:                         cls.column_size = 2
    2:                         cls.box_width = (20 + 13 if cpu.got_sensors else 21) * cls.box_columns - ((cls.box_columns - 1) * 1)
                       elif cls.box_columns * (15 + 6 if cpu.got_sensors else 15) < cls.width - (cls.width // 3):
                               cls.column_size = 1
                               cls.box_width = (15 + 6 if cpu.got_sensors else 15) * cls.box_columns - ((cls.box_columns - 1) * 1)
                       elif cls.box_columns * (8 + 6 if cpu.got_sensors else 8) < cls.width - (cls.width // 3):
                               cls.column_size = 0
                       else:
                               cls.box_columns = (cls.width - cls.width // 3) // (8 + 6 if cpu.got_sensors else 8); cls.column_size = 0
       
    2:                 if cls.column_size == 0: cls.box_width = (8 + 6 if cpu.got_sensors else 8) * cls.box_columns + 1
       
    2:                 cls.box_height = ceil(THREADS / cls.box_columns) + 4
       
    2:                 if cls.box_height > cls.height - 2: cls.box_height = cls.height - 2
    2:                 cls.box_x = (cls.width - 1) - cls.box_width
    2:                 cls.box_y = cls.y + ceil((cls.height - 2) / 2) - ceil(cls.box_height / 2) + 1
       
    1:         @classmethod
    1:         def _draw_bg(cls) -> str:
    2:                 if not "cpu" in cls.boxes: return ""
    2:                 if not "M" in Key.mouse:
   16:                         Key.mouse["M"] = [[cls.x + 10 + i, cls.y] for i in range(6)]
    2:                 return (f'{create_box(box=cls, line_color=THEME.cpu_box)}'
                       f'{Mv.to(cls.y, cls.x + 10)}{THEME.cpu_box(Symbol.title_left)}{Fx.b}{THEME.hi_fg("M")}{THEME.title("enu")}{Fx.ub}{THEME.cpu_box(Symbol.title_right)}'
                       f'{create_box(x=cls.box_x, y=cls.box_y, width=cls.box_width, height=cls.box_height, line_color=THEME.div_line, fill=False, title=CPU_NAME[:cls.box_width - 14] if not CONFIG.custom_cpu_name else CONFIG.custom_cpu_name[:cls.box_width - 14])}')
       
    1:         @classmethod
    1:         def battery_activity(cls) -> bool:
    2:                 if not hasattr(psutil, "sensors_battery") or psutil.sensors_battery() == None:
                               if cls.battery_percent != 1000:
                                       cls.battery_clear = True
                               return False
       
    2:                 if cls.battery_path == "":
    1:                         cls.battery_path = None
    1:                         if os.path.isdir("/sys/class/power_supply"):
                                       for directory in sorted(os.listdir("/sys/class/power_supply")):
                                               if directory.startswith('BAT') or 'battery' in directory.lower():
                                                       cls.battery_path = f'/sys/class/power_supply/{directory}/'
                                                       break
       
    2:                 return_true: bool = False
    2:                 percent: int = ceil(getattr(psutil.sensors_battery(), "percent", 0))
    2:                 if percent != cls.battery_percent:
    1:                         cls.battery_percent = percent
    1:                         return_true = True
       
    2:                 seconds: int = getattr(psutil.sensors_battery(), "secsleft", 0)
    2:                 if seconds != cls.battery_secs:
    1:                         cls.battery_secs = seconds
    1:                         return_true = True
       
    2:                 status: str = "not_set"
    2:                 if cls.battery_path:
                               status = readfile(cls.battery_path + "status", default="not_set")
    2:                 if status == "not_set" and getattr(psutil.sensors_battery(), "power_plugged", None) == True:
    2:                         status = "Charging" if cls.battery_percent < 100 else "Full"
                       elif status == "not_set" and getattr(psutil.sensors_battery(), "power_plugged", None) == False:
                               status = "Discharging"
                       elif status == "not_set":
                               status = "Unknown"
    2:                 if status != cls.battery_status:
    1:                         cls.battery_status = status
    1:                         return_true = True
       
    2:                 return return_true or cls.resized or cls.redraw or Menu.active
       
    1:         @classmethod
    1:         def _draw_fg(cls):
    2:                 if not "cpu" in cls.boxes: return
    2:                 cpu = CpuCollector
    2:                 if cpu.redraw: cls.redraw = True
    2:                 out: str = ""
    2:                 out_misc: str = ""
    2:                 lavg: str = ""
    2:                 x, y, w, h = cls.x + 1, cls.y + 1, cls.width - 2, cls.height - 2
    2:                 bx, by, bw, bh = cls.box_x + 1, cls.box_y + 1, cls.box_width - 2, cls.box_height - 2
    2:                 hh: int = ceil(h / 2)
    2:                 hh2: int = h - hh
    2:                 mid_line: bool = False
    2:                 temp: int = 0
    2:                 unit: str = ""
    2:                 if not CONFIG.cpu_single_graph and CONFIG.cpu_graph_upper != CONFIG.cpu_graph_lower:
                               mid_line = True
                               if h % 2: hh = floor(h / 2)
                               else: hh2 -= 1
       
    2:                 hide_cores: bool = (cpu.cpu_temp_only or not CONFIG.show_coretemp) and cpu.got_sensors
    2:                 ct_width: int = (max(6, 6 * cls.column_size)) * hide_cores
       
    2:                 if cls.resized or cls.redraw:
    2:                         if not "m" in Key.mouse:
   28:                                 Key.mouse["m"] = [[cls.x + 16 + i, cls.y] for i in range(12)]
    2:                         out_misc += f'{Mv.to(cls.y, cls.x + 16)}{THEME.cpu_box(Symbol.title_left)}{Fx.b}{THEME.hi_fg("m")}{THEME.title}ode:{Box.view_mode}{Fx.ub}{THEME.cpu_box(Symbol.title_right)}'
    2:                         Graphs.cpu["up"] = Graph(w - bw - 3, (h if CONFIG.cpu_single_graph else hh), THEME.gradient["cpu"], cpu.cpu_upper, round_up_low=True)
    2:                         if not CONFIG.cpu_single_graph:
    2:                                 Graphs.cpu["down"] = Graph(w - bw - 3, hh2, THEME.gradient["cpu"], cpu.cpu_lower, invert=CONFIG.cpu_invert_lower, round_up_low=True)
    2:                         Meters.cpu = Meter(cpu.cpu_usage[0][-1], bw - (21 if cpu.got_sensors else 9), "cpu")
    2:                         if cls.column_size > 0 or ct_width > 0:
   18:                                 for n in range(THREADS):
   16:                                         Graphs.cores[n] = Graph(5 * cls.column_size + ct_width, 1, None, cpu.cpu_usage[n + 1])
    2:                         if cpu.got_sensors:
    2:                                 Graphs.temps[0] = Graph(5, 1, None, cpu.cpu_temp[0], max_value=cpu.cpu_temp_crit, offset=-23)
    2:                                 if cls.column_size > 1:
   18:                                         for n in range(1, THREADS + 1):
   16:                                                 if not cpu.cpu_temp[n]:
   16:                                                         continue
                                                       Graphs.temps[n] = Graph(5, 1, None, cpu.cpu_temp[n], max_value=cpu.cpu_temp_crit, offset=-23)
    2:                         Draw.buffer("cpu_misc", out_misc, only_save=True)
       
    2:                 if CONFIG.show_battery and cls.battery_activity():
    2:                         bat_out: str = ""
    2:                         if cls.battery_secs > 0:
                                       battery_time: str = f' {cls.battery_secs // 3600:02}:{(cls.battery_secs % 3600) // 60:02}'
                               else:
    2:                                 battery_time = ""
    2:                         if not hasattr(Meters, "battery") or cls.resized:
    2:                                 Meters.battery = Meter(cls.battery_percent, 10, "cpu", invert=True)
    2:                         battery_symbol: str = cls.battery_symbols.get(cls.battery_status, "○")
    2:                         battery_len: int = len(f'{CONFIG.update_ms}') + (11 if cls.width >= 100 else 0) + len(battery_time) + len(f'{cls.battery_percent}')
    2:                         battery_pos = cls.width - battery_len - 17
    2:                         if (battery_pos != cls.old_battery_pos or battery_len != cls.old_battery_len) and cls.old_battery_pos > 0 and not cls.resized:
                                       bat_out += f'{Mv.to(y-1, cls.old_battery_pos)}{THEME.cpu_box(Symbol.h_line*(cls.old_battery_len+4))}'
    2:                         cls.old_battery_pos, cls.old_battery_len = battery_pos, battery_len
    6:                         bat_out += (f'{Mv.to(y-1, battery_pos)}{THEME.cpu_box(Symbol.title_left)}{Fx.b}{THEME.title}BAT{battery_symbol} {cls.battery_percent}%'+
    2:                                 ("" if cls.width < 100 else f' {Fx.ub}{Meters.battery(cls.battery_percent)}{Fx.b}') +
    2:                                 f'{THEME.title}{battery_time}{Fx.ub}{THEME.cpu_box(Symbol.title_right)}')
    2:                         Draw.buffer("battery", f'{bat_out}{Term.fg}', only_save=Menu.active)
                       elif cls.battery_clear:
                               out += f'{Mv.to(y-1, cls.old_battery_pos)}{THEME.cpu_box(Symbol.h_line*(cls.old_battery_len+4))}'
                               cls.battery_clear = False
                               cls.battery_percent = 1000
                               cls.battery_secs = 0
                               cls.battery_status = "Unknown"
                               cls.old_battery_pos = 0
                               cls.old_battery_len = 0
                               cls.battery_path = ""
                               Draw.clear("battery", saved=True)
       
    2:                 cx = cy = cc = 0
    2:                 ccw = (bw + 1) // cls.box_columns
    2:                 if cpu.cpu_freq:
    2:                         freq: str = f'{cpu.cpu_freq} Mhz' if cpu.cpu_freq < 1000 else f'{float(cpu.cpu_freq / 1000):.1f} GHz'
    2:                         out += f'{Mv.to(by - 1, bx + bw - 9)}{THEME.div_line(Symbol.title_left)}{Fx.b}{THEME.title(freq)}{Fx.ub}{THEME.div_line(Symbol.title_right)}'
    2:                 out += f'{Mv.to(y, x)}{Graphs.cpu["up"](None if cls.resized else cpu.cpu_upper[-1])}'
    2:                 if mid_line:
                               out += (f'{Mv.to(y+hh, x-1)}{THEME.cpu_box(Symbol.title_right)}{THEME.div_line}{Symbol.h_line * (w - bw - 3)}{THEME.div_line(Symbol.title_left)}'
                                               f'{Mv.to(y+hh, x+((w-bw)//2)-((len(CONFIG.cpu_graph_upper)+len(CONFIG.cpu_graph_lower))//2)-4)}{THEME.main_fg}{CONFIG.cpu_graph_upper}{Mv.r(1)}▲▼{Mv.r(1)}{CONFIG.cpu_graph_lower}')
    2:                 if not CONFIG.cpu_single_graph and Graphs.cpu.get("down"):
    2:                         out += f'{Mv.to(y + hh + (1 * mid_line), x)}{Graphs.cpu["down"](None if cls.resized else cpu.cpu_lower[-1])}'
    2:                 out += (f'{THEME.main_fg}{Mv.to(by + cy, bx + cx)}{Fx.b}{"CPU "}{Fx.ub}{Meters.cpu(cpu.cpu_usage[0][-1])}'
                                       f'{THEME.gradient["cpu"][cpu.cpu_usage[0][-1]]}{cpu.cpu_usage[0][-1]:>4}{THEME.main_fg}%')
    2:                 if cpu.got_sensors:
    2:                         try:
    2:                                 temp, unit = temperature(cpu.cpu_temp[0][-1], CONFIG.temp_scale)
    2:                                 out += (f'{THEME.inactive_fg} ⡀⡀⡀⡀⡀{Mv.l(5)}{THEME.gradient["temp"][min_max(cpu.cpu_temp[0][-1], 0, cpu.cpu_temp_crit) * 100 // cpu.cpu_temp_crit]}{Graphs.temps[0](None if cls.resized else cpu.cpu_temp[0][-1])}'
                                                       f'{temp:>4}{THEME.main_fg}{unit}')
                               except:
                                       cpu.got_sensors = False
       
    2:                 cy += 1
   18:                 for n in range(1, THREADS + 1):
   16:                         out += f'{THEME.main_fg}{Mv.to(by + cy, bx + cx)}{Fx.b + "C" + Fx.ub if THREADS < 100 else ""}{str(n):<{2 if cls.column_size == 0 else 3}}'
   16:                         if cls.column_size > 0 or ct_width > 0:
   16:                                 out += f'{THEME.inactive_fg}{"⡀" * (5 * cls.column_size + ct_width)}{Mv.l(5 * cls.column_size + ct_width)}{THEME.gradient["cpu"][cpu.cpu_usage[n][-1]]}{Graphs.cores[n-1](None if cls.resized else cpu.cpu_usage[n][-1])}'
                               else:
                                       out += f'{THEME.gradient["cpu"][cpu.cpu_usage[n][-1]]}'
   16:                         out += f'{cpu.cpu_usage[n][-1]:>{3 if cls.column_size < 2 else 4}}{THEME.main_fg}%'
   16:                         if cpu.got_sensors and cpu.cpu_temp[n] and not hide_cores:
                                       try:
                                               temp, unit = temperature(cpu.cpu_temp[n][-1], CONFIG.temp_scale)
                                               if cls.column_size > 1:
                                                       out += f'{THEME.inactive_fg} ⡀⡀⡀⡀⡀{Mv.l(5)}{THEME.gradient["temp"][min_max(cpu.cpu_temp[n][-1], 0, cpu.cpu_temp_crit) * 100 // cpu.cpu_temp_crit]}{Graphs.temps[n](None if cls.resized else cpu.cpu_temp[n][-1])}'
                                               else:
                                                       out += f'{THEME.gradient["temp"][min_max(temp, 0, cpu.cpu_temp_crit) * 100 // cpu.cpu_temp_crit]}'
                                               out += f'{temp:>4}{THEME.main_fg}{unit}'
                                       except:
                                               cpu.got_sensors = False
   16:                         elif cpu.got_sensors and not hide_cores:
                                       out += f'{Mv.r(max(6, 6 * cls.column_size))}'
   16:                         out += f'{THEME.div_line(Symbol.v_line)}'
   16:                         cy += 1
   16:                         if cy > ceil(THREADS/cls.box_columns) and n != THREADS:
    2:                                 cc += 1; cy = 1; cx = ccw * cc
    2:                                 if cc == cls.box_columns: break
       
    2:                 if cy < bh - 1: cy = bh - 1
       
    2:                 if cy < bh and cc < cls.box_columns:
    2:                         if cls.column_size == 2 and cpu.got_sensors:
   10:                                 lavg = f' Load AVG:  {"   ".join(str(l) for l in cpu.load_avg):^19.19}'
                               elif cls.column_size == 2 or (cls.column_size == 1 and cpu.got_sensors):
                                       lavg = f'LAV: {" ".join(str(l) for l in cpu.load_avg):^14.14}'
                               elif cls.column_size == 1 or (cls.column_size == 0 and cpu.got_sensors):
                                       lavg = f'L {" ".join(str(round(l, 1)) for l in cpu.load_avg):^11.11}'
                               else:
                                       lavg = f'{" ".join(str(round(l, 1)) for l in cpu.load_avg[:2]):^7.7}'
    2:                         out += f'{Mv.to(by + cy, bx + cx)}{THEME.main_fg}{lavg}{THEME.div_line(Symbol.v_line)}'
       
    2:                 if CONFIG.show_uptime:
    2:                         out += f'{Mv.to(y + (0 if not CONFIG.cpu_invert_lower or CONFIG.cpu_single_graph else h - 1), x + 1)}{THEME.graph_text}{Fx.trans("up " + cpu.uptime)}'
       
       
    2:                 Draw.buffer(cls.buffer, f'{out_misc}{out}{Term.fg}', only_save=Menu.active)
    2:                 cls.resized = cls.redraw = cls.clock_block = False
       
    2: class MemBox(Box):
    1:         name = "mem"
    1:         num = 2
    1:         height_p = 38
    1:         width_p = 45
    1:         min_w: int = 36
    1:         min_h: int = 10
    1:         x = 1
    1:         y = 1
    1:         mem_meter: int = 0
    1:         mem_size: int = 0
    1:         disk_meter: int = 0
    1:         divider: int = 0
    1:         mem_width: int = 0
    1:         disks_width: int = 0
    1:         disks_io_h: int = 0
    1:         disks_io_order: List[str] = []
    1:         graph_speeds: Dict[str, int] = {}
    1:         graph_height: int
    1:         resized: bool = True
    1:         redraw: bool = False
    1:         buffer: str = "mem"
    1:         swap_on: bool = CONFIG.show_swap
    1:         Box.buffers.append(buffer)
    1:         mem_names: List[str] = ["used", "available", "cached", "free"]
    1:         swap_names: List[str] = ["used", "free"]
       
    1:         @classmethod
    1:         def _calc_size(cls):
    4:                 if not "mem" in cls.boxes:
                               Box._b_mem_h = 0
                               cls.width = Term.width
                               return
                       width_p: int; height_p: int
    4:                 if not "proc" in cls.boxes:
    4:                         width_p = 100
                       else:
                               width_p = cls.width_p
       
    4:                 if not "cpu" in cls.boxes:
                               height_p = 60 if "net" in cls.boxes else 98
    4:                 elif not "net" in cls.boxes:
                               height_p = 98 - CpuBox.height_p
                       else:
    4:                         height_p = cls.height_p
       
    4:                 cls.width = round(Term.width * width_p / 100)
    4:                 cls.height = round(Term.height * height_p / 100) + 1
    4:                 if cls.height + Box._b_cpu_h > Term.height: cls.height = Term.height - Box._b_cpu_h
    4:                 Box._b_mem_h = cls.height
    4:                 cls.y = Box._b_cpu_h + 1
    4:                 if CONFIG.show_disks:
    4:                         cls.mem_width = ceil((cls.width - 3) / 2)
    4:                         cls.disks_width = cls.width - cls.mem_width - 3
    4:                         if cls.mem_width + cls.disks_width < cls.width - 2: cls.mem_width += 1
    4:                         cls.divider = cls.x + cls.mem_width
                       else:
                               cls.mem_width = cls.width - 1
       
    4:                 item_height: int = 6 if cls.swap_on and not CONFIG.swap_disk else 4
    4:                 if cls.height - (3 if cls.swap_on and not CONFIG.swap_disk else 2) > 2 * item_height: cls.mem_size = 3
                       elif cls.mem_width > 25: cls.mem_size = 2
                       else: cls.mem_size = 1
       
    4:                 cls.mem_meter = cls.width - (cls.disks_width if CONFIG.show_disks else 0) - (9 if cls.mem_size > 2 else 20)
    4:                 if cls.mem_size == 1: cls.mem_meter += 6
    4:                 if cls.mem_meter < 1: cls.mem_meter = 0
       
    4:                 if CONFIG.mem_graphs:
    4:                         cls.graph_height = round(((cls.height - (2 if cls.swap_on and not CONFIG.swap_disk else 1)) - (2 if cls.mem_size == 3 else 1) * item_height) / item_height)
    4:                         if cls.graph_height == 0: cls.graph_height = 1
    4:                         if cls.graph_height > 1: cls.mem_meter += 6
                       else:
                               cls.graph_height = 0
       
    4:                 if CONFIG.show_disks:
    4:                         cls.disk_meter = cls.width - cls.mem_width - 23
    4:                         if cls.disks_width < 25:
                                       cls.disk_meter += 10
    4:                         if cls.disk_meter < 1: cls.disk_meter = 0
       
    1:         @classmethod
    1:         def _draw_bg(cls) -> str:
    4:                 if not "mem" in cls.boxes: return ""
    4:                 out: str = ""
    4:                 out += f'{create_box(box=cls, line_color=THEME.mem_box)}'
    4:                 if CONFIG.show_disks:
   52:                         out += (f'{Mv.to(cls.y, cls.divider + 2)}{THEME.mem_box(Symbol.title_left)}{Fx.b}{THEME.hi_fg("d")}{THEME.title("isks")}{Fx.ub}{THEME.mem_box(Symbol.title_right)}'
                                               f'{Mv.to(cls.y, cls.divider)}{THEME.mem_box(Symbol.div_up)}'
                                               f'{Mv.to(cls.y + cls.height - 1, cls.divider)}{THEME.mem_box(Symbol.div_down)}{THEME.div_line}'
                                               f'{"".join(f"{Mv.to(cls.y + i, cls.divider)}{Symbol.v_line}" for i in range(1, cls.height - 1))}')
   28:                         Key.mouse["d"] = [[cls.divider + 3 + i, cls.y] for i in range(5)]
                       else:
                               out += f'{Mv.to(cls.y, cls.x + cls.width - 9)}{THEME.mem_box(Symbol.title_left)}{THEME.hi_fg("d")}{THEME.title("isks")}{THEME.mem_box(Symbol.title_right)}'
                               Key.mouse["d"] = [[cls.x + cls.width - 8 + i, cls.y] for i in range(5)]
    4:                 return out
       
    1:         @classmethod
    1:         def _draw_fg(cls):
    2:                 if not "mem" in cls.boxes: return
    2:                 mem = MemCollector
    2:                 if mem.redraw: cls.redraw = True
    2:                 out: str = ""
    2:                 out_misc: str = ""
    2:                 gbg: str = ""
    2:                 gmv: str = ""
    2:                 gli: str = ""
    2:                 x, y, w, h = cls.x + 1, cls.y + 1, cls.width - 2, cls.height - 2
    2:                 if cls.resized or cls.redraw:
    2:                         cls.redraw = True
    2:                         cls._calc_size()
    2:                         out_misc += cls._draw_bg()
    2:                         Meters.mem = {}
    2:                         Meters.swap = {}
    2:                         Meters.disks_used = {}
    2:                         Meters.disks_free = {}
    2:                         if cls.mem_meter > 0:
   10:                                 for name in cls.mem_names:
    8:                                         if CONFIG.mem_graphs:
    8:                                                 Meters.mem[name] = Graph(cls.mem_meter, cls.graph_height, THEME.gradient[name], mem.vlist[name])
                                               else:
                                                       Meters.mem[name] = Meter(mem.percent[name], cls.mem_meter, name)
    2:                                 if cls.swap_on:
    2:                                         for name in cls.swap_names:
    2:                                                 if CONFIG.swap_disk and CONFIG.show_disks:
    2:                                                         break
                                                       elif CONFIG.mem_graphs and not CONFIG.swap_disk:
                                                               Meters.swap[name] = Graph(cls.mem_meter, cls.graph_height, THEME.gradient[name], mem.swap_vlist[name])
                                                       else:
                                                               Meters.swap[name] = Meter(mem.swap_percent[name], cls.mem_meter, name)
       
    2:                         if CONFIG.show_disks and mem.disks:
    2:                                 if CONFIG.show_io_stat or CONFIG.io_mode:
    2:                                         d_graph: List[str] = []
    2:                                         d_no_graph: List[str] = []
    2:                                         l_vals: List[Tuple[str, int, str, bool]] = []
    2:                                         if CONFIG.io_mode:
                                                       cls.disks_io_h = (cls.height - 2 - len(mem.disks)) // max(1, len(mem.disks_io_dict))
                                                       if cls.disks_io_h < 2: cls.disks_io_h = 1 if CONFIG.io_graph_combined else 2
                                               else:
    2:                                                 cls.disks_io_h = 1
       
    2:                                         if CONFIG.io_graph_speeds and not cls.graph_speeds:
                                                       try:
                                                               cls.graph_speeds = { spds.split(":")[0] : int(spds.split(":")[1]) for spds in list(i.strip() for i in CONFIG.io_graph_speeds.split(","))}
                                                       except (KeyError, ValueError):
                                                               errlog.error("Wrong formatting in io_graph_speeds variable. Using defaults.")
   24:                                         for name in mem.disks.keys():
   22:                                                 if name in mem.disks_io_dict:
    7:                                                         d_graph.append(name)
                                                       else:
   15:                                                         d_no_graph.append(name)
   15:                                                         continue
    7:                                                 if CONFIG.io_graph_combined or not CONFIG.io_mode:
    7:                                                         l_vals = [("rw", cls.disks_io_h, "available", False)]
                                                       else:
                                                               l_vals = [("read", cls.disks_io_h // 2, "free", False), ("write", cls.disks_io_h // 2, "used", True)]
       
   42:                                                 Graphs.disk_io[name] = {_name : Graph(width=cls.disks_width - (6 if not CONFIG.io_mode else 0), height=_height, color=THEME.gradient[_gradient],
    7:                                                                                                 data=mem.disks_io_dict[name][_name], invert=_invert, max_value=cls.graph_speeds.get(name, 10), no_zero=True)
   14:                                                                                                 for _name, _height, _gradient, _invert in l_vals}
    2:                                         cls.disks_io_order = d_graph + d_no_graph
       
    2:                                 if cls.disk_meter > 0:
   14:                                         for n, name in enumerate(mem.disks.keys()):
   14:                                                 if n * 2 > h: break
   12:                                                 Meters.disks_used[name] = Meter(mem.disks[name]["used_percent"], cls.disk_meter, "used")
   12:                                                 if len(mem.disks) * 3 <= h + 1:
                                                               Meters.disks_free[name] = Meter(mem.disks[name]["free_percent"], cls.disk_meter, "free")
    2:                         if not "g" in Key.mouse:
   14:                                 Key.mouse["g"] = [[x + 8 + i, y-1] for i in range(5)]
    2:                         out_misc += (f'{Mv.to(y-1, x + 7)}{THEME.mem_box(Symbol.title_left)}{Fx.b if CONFIG.mem_graphs else ""}'
                                       f'{THEME.hi_fg("g")}{THEME.title("raph")}{Fx.ub}{THEME.mem_box(Symbol.title_right)}')
    2:                         if CONFIG.show_disks:
    2:                                 if not "s" in Key.mouse:
   12:                                         Key.mouse["s"] = [[x + w - 6 + i, y-1] for i in range(4)]
    2:                                 out_misc += (f'{Mv.to(y-1, x + w - 7)}{THEME.mem_box(Symbol.title_left)}{Fx.b if CONFIG.swap_disk else ""}'
                                       f'{THEME.hi_fg("s")}{THEME.title("wap")}{Fx.ub}{THEME.mem_box(Symbol.title_right)}')
    2:                                 if not "i" in Key.mouse:
    8:                                         Key.mouse["i"] = [[x + w - 10 + i, y-1] for i in range(2)]
    2:                                 out_misc += (f'{Mv.to(y-1, x + w - 11)}{THEME.mem_box(Symbol.title_left)}{Fx.b if CONFIG.io_mode else ""}'
                                       f'{THEME.hi_fg("i")}{THEME.title("o")}{Fx.ub}{THEME.mem_box(Symbol.title_right)}')
       
    2:                         if Collector.collect_interrupt: return
    2:                         Draw.buffer("mem_misc", out_misc, only_save=True)
    2:                 try:
                               #* Mem
    2:                         cx = 1; cy = 1
       
    2:                         out += f'{Mv.to(y, x+1)}{THEME.title}{Fx.b}Total:{mem.string["total"]:>{cls.mem_width - 9}}{Fx.ub}{THEME.main_fg}'
    2:                         if cls.graph_height > 0:
    2:                                 gli = f'{Mv.l(2)}{THEME.mem_box(Symbol.title_right)}{THEME.div_line}{Symbol.h_line * (cls.mem_width - 1)}{"" if CONFIG.show_disks else THEME.mem_box}{Symbol.title_left}{Mv.l(cls.mem_width - 1)}{THEME.title}'
    2:                         if cls.graph_height >= 2:
                                       gbg = f'{Mv.l(1)}'
                                       gmv = f'{Mv.l(cls.mem_width - 2)}{Mv.u(cls.graph_height - 1)}'
       
    2:                         big_mem: bool = cls.mem_width > 21
   10:                         for name in cls.mem_names:
    8:                                 if cy > h - 1: break
    8:                                 if Collector.collect_interrupt: return
    8:                                 if cls.mem_size > 2:
    8:                                         out += (f'{Mv.to(y+cy, x+cx)}{gli}{name.capitalize()[:None if big_mem else 5]+":":<{1 if big_mem else 6.6}}{Mv.to(y+cy, x+cx + cls.mem_width - 3 - (len(mem.string[name])))}{Fx.trans(mem.string[name])}'
                                                               f'{Mv.to(y+cy+1, x+cx)}{gbg}{Meters.mem[name](None if cls.resized else mem.percent[name])}{gmv}{str(mem.percent[name])+"%":>4}')
    8:                                         cy += 2 if not cls.graph_height else cls.graph_height + 1
                                       else:
                                               out += f'{Mv.to(y+cy, x+cx)}{name.capitalize():{5.5 if cls.mem_size > 1 else 1.1}} {gbg}{Meters.mem[name](None if cls.resized else mem.percent[name])}{mem.string[name][:None if cls.mem_size > 1 else -2]:>{9 if cls.mem_size > 1 else 7}}'
                                               cy += 1 if not cls.graph_height else cls.graph_height
                               #* Swap
    2:                         if cls.swap_on and CONFIG.show_swap and not CONFIG.swap_disk and mem.swap_string:
                                       if h - cy > 5:
                                               if cls.graph_height > 0: out += f'{Mv.to(y+cy, x+cx)}{gli}'
                                               cy += 1
       
                                       out += f'{Mv.to(y+cy, x+cx)}{THEME.title}{Fx.b}Swap:{mem.swap_string["total"]:>{cls.mem_width - 8}}{Fx.ub}{THEME.main_fg}'
                                       cy += 1
                                       for name in cls.swap_names:
                                               if cy > h - 1: break
                                               if Collector.collect_interrupt: return
                                               if cls.mem_size > 2:
                                                       out += (f'{Mv.to(y+cy, x+cx)}{gli}{name.capitalize()[:None if big_mem else 5]+":":<{1 if big_mem else 6.6}}{Mv.to(y+cy, x+cx + cls.mem_width - 3 - (len(mem.swap_string[name])))}{Fx.trans(mem.swap_string[name])}'
                                                                       f'{Mv.to(y+cy+1, x+cx)}{gbg}{Meters.swap[name](None if cls.resized else mem.swap_percent[name])}{gmv}{str(mem.swap_percent[name])+"%":>4}')
                                                       cy += 2 if not cls.graph_height else cls.graph_height + 1
                                               else:
                                                       out += f'{Mv.to(y+cy, x+cx)}{name.capitalize():{5.5 if cls.mem_size > 1 else 1.1}} {gbg}{Meters.swap[name](None if cls.resized else mem.swap_percent[name])}{mem.swap_string[name][:None if cls.mem_size > 1 else -2]:>{9 if cls.mem_size > 1 else 7}}'; cy += 1 if not cls.graph_height else cls.graph_height
       
    2:                         if cls.graph_height > 0 and not cy == h: out += f'{Mv.to(y+cy, x+cx)}{gli}'
       
                               #* Disks
    2:                         if CONFIG.show_disks and mem.disks:
    2:                                 cx = x + cls.mem_width - 1; cy = 0
    2:                                 big_disk: bool = cls.disks_width >= 25
    2:                                 gli = f'{Mv.l(2)}{THEME.div_line}{Symbol.title_right}{Symbol.h_line * cls.disks_width}{THEME.mem_box}{Symbol.title_left}{Mv.l(cls.disks_width - 1)}'
    2:                                 if CONFIG.io_mode:
                                               for name in cls.disks_io_order:
                                                       item = mem.disks[name]
                                                       io_item = mem.disks_io_dict.get(name, {})
                                                       if Collector.collect_interrupt: return
                                                       if cy > h - 1: break
                                                       out += Fx.trans(f'{Mv.to(y+cy, x+cx)}{gli}{THEME.title}{Fx.b}{item["name"]:{cls.disks_width - 2}.12}{Mv.to(y+cy, x + cx + cls.disks_width - 11)}{item["total"][:None if big_disk else -2]:>9}')
                                                       if big_disk:
                                                               out += Fx.trans(f'{Mv.to(y+cy, x + cx + (cls.disks_width // 2) - (len(str(item["used_percent"])) // 2) - 2)}{Fx.ub}{THEME.main_fg}{item["used_percent"]}%')
                                                       cy += 1
       
                                                       if io_item:
                                                               if cy > h - 1: break
                                                               if CONFIG.io_graph_combined:
                                                                       if cls.disks_io_h <= 1:
                                                                               out += f'{Mv.to(y+cy, x+cx-1)}{" " * 5}'
                                                                       out += (f'{Mv.to(y+cy, x+cx-1)}{Fx.ub}{Graphs.disk_io[name]["rw"](None if cls.redraw else mem.disks_io_dict[name]["rw"][-1])}'
                                                                                       f'{Mv.to(y+cy, x+cx-1)}{THEME.main_fg}{item["io"] or "RW"}')
                                                                       cy += cls.disks_io_h
                                                               else:
                                                                       if cls.disks_io_h <= 3:
                                                                               out += f'{Mv.to(y+cy, x+cx-1)}{" " * 5}{Mv.to(y+cy+1, x+cx-1)}{" " * 5}'
                                                                       out += (f'{Mv.to(y+cy, x+cx-1)}{Fx.ub}{Graphs.disk_io[name]["read"](None if cls.redraw else mem.disks_io_dict[name]["read"][-1])}'
                                                                                       f'{Mv.to(y+cy, x+cx-1)}{THEME.main_fg}{item["io_r"] or "R"}')
                                                                       cy += cls.disks_io_h // 2
                                                                       out += f'{Mv.to(y+cy, x+cx-1)}{Graphs.disk_io[name]["write"](None if cls.redraw else mem.disks_io_dict[name]["write"][-1])}'
                                                                       cy += cls.disks_io_h // 2
                                                                       out += f'{Mv.to(y+cy-1, x+cx-1)}{THEME.main_fg}{item["io_w"] or "W"}'
                                       else:
   11:                                         for name, item in mem.disks.items():
   11:                                                 if Collector.collect_interrupt: return
   11:                                                 if not name in Meters.disks_used:
                                                               continue
   11:                                                 if cy > h - 1: break
   10:                                                 out += Fx.trans(f'{Mv.to(y+cy, x+cx)}{gli}{THEME.title}{Fx.b}{item["name"]:{cls.disks_width - 2}.12}{Mv.to(y+cy, x + cx + cls.disks_width - 11)}{item["total"][:None if big_disk else -2]:>9}')
   10:                                                 if big_disk:
   10:                                                         out += f'{Mv.to(y+cy, x + cx + (cls.disks_width // 2) - (len(item["io"]) // 2) - 2)}{Fx.ub}{THEME.main_fg}{Fx.trans(item["io"])}'
   10:                                                 cy += 1
   10:                                                 if cy > h - 1: break
    9:                                                 if CONFIG.show_io_stat and name in Graphs.disk_io:
    3:                                                         out += f'{Mv.to(y+cy, x+cx-1)}{THEME.main_fg}{Fx.ub}{" IO: " if big_disk else " IO   " + Mv.l(2)}{Fx.ub}{Graphs.disk_io[name]["rw"](None if cls.redraw else mem.disks_io_dict[name]["rw"][-1])}'
    3:                                                         if not big_disk and item["io"]:
                                                                       out += f'{Mv.to(y+cy, x+cx-1)}{Fx.ub}{THEME.main_fg}{item["io"]}'
    3:                                                         cy += 1
    3:                                                         if cy > h - 1: break
    9:                                                 out += Mv.to(y+cy, x+cx) + (f'Used:{str(item["used_percent"]) + "%":>4} ' if big_disk else "U ")
    9:                                                 out += f'{Meters.disks_used[name](None if cls.resized else mem.disks[name]["used_percent"])}{item["used"][:None if big_disk else -2]:>{9 if big_disk else 7}}'
    9:                                                 cy += 1
       
    9:                                                 if len(mem.disks) * 3 + (len(mem.disks_io_dict) if CONFIG.show_io_stat else 0) <= h + 1:
                                                               if cy > h - 1: break
                                                               out += Mv.to(y+cy, x+cx)
                                                               out += f'Free:{str(item["free_percent"]) + "%":>4} ' if big_disk else f'{"F "}'
                                                               out += f'{Meters.disks_free[name](None if cls.resized else mem.disks[name]["free_percent"])}{item["free"][:None if big_disk else -2]:>{9 if big_disk else 7}}'
                                                               cy += 1
                                                               if len(mem.disks) * 4 + (len(mem.disks_io_dict) if CONFIG.show_io_stat else 0) <= h + 1: cy += 1
                       except (KeyError, TypeError):
                               return
    2:                 Draw.buffer(cls.buffer, f'{out_misc}{out}{Term.fg}', only_save=Menu.active)
    2:                 cls.resized = cls.redraw = False
       
    2: class NetBox(Box, SubBox):
    1:         name = "net"
    1:         num = 3
    1:         height_p = 30
    1:         width_p = 45
    1:         min_w: int = 36
    1:         min_h: int = 6
    1:         x = 1
    1:         y = 1
    1:         resized: bool = True
    1:         redraw: bool = True
    1:         graph_height: Dict[str, int] = {}
    1:         symbols: Dict[str, str] = {"download" : "▼", "upload" : "▲"}
    1:         buffer: str = "net"
       
    1:         Box.buffers.append(buffer)
       
    1:         @classmethod
    1:         def _calc_size(cls):
    2:                 if not "net" in cls.boxes:
                               cls.width = Term.width
                               return
    2:                 if not "proc" in cls.boxes:
    2:                         width_p = 100
                       else:
                               width_p = cls.width_p
       
    2:                 cls.width = round(Term.width * width_p / 100)
    2:                 cls.height = Term.height - Box._b_cpu_h - Box._b_mem_h
    2:                 cls.y = Term.height - cls.height + 1
    2:                 cls.box_width = 27 if cls.width > 45 else 19
    2:                 cls.box_height = 9 if cls.height > 10 else cls.height - 2
    2:                 cls.box_x = cls.width - cls.box_width - 1
    2:                 cls.box_y = cls.y + ((cls.height - 2) // 2) - cls.box_height // 2 + 1
    2:                 cls.graph_height["download"] = round((cls.height - 2) / 2)
    2:                 cls.graph_height["upload"] = cls.height - 2 - cls.graph_height["download"]
    2:                 cls.redraw = True
       
    1:         @classmethod
    1:         def _draw_bg(cls) -> str:
    4:                 if not "net" in cls.boxes: return ""
    8:                 return f'{create_box(box=cls, line_color=THEME.net_box)}\
    4:                 {create_box(x=cls.box_x, y=cls.box_y, width=cls.box_width, height=cls.box_height, line_color=THEME.div_line, fill=False, title="Download", title2="Upload")}'
       
    1:         @classmethod
    1:         def _draw_fg(cls):
    2:                 if not "net" in cls.boxes: return
    2:                 net = NetCollector
    2:                 if net.redraw: cls.redraw = True
    2:                 if not net.nic: return
    2:                 out: str = ""
    2:                 out_misc: str = ""
    2:                 x, y, w, h = cls.x + 1, cls.y + 1, cls.width - 2, cls.height - 2
    2:                 bx, by, bw, bh = cls.box_x + 1, cls.box_y + 1, cls.box_width - 2, cls.box_height - 2
    2:                 reset: bool = bool(net.stats[net.nic]["download"]["offset"])
       
    2:                 if cls.resized or cls.redraw:
    2:                         out_misc += cls._draw_bg()
   12:                         Key.mouse["b"] = [[x+w - len(net.nic[:10]) - 9 + i, y-1] for i in range(4)]
   12:                         Key.mouse["n"] = [[x+w - 5 + i, y-1] for i in range(4)]
   12:                         Key.mouse["z"] = [[x+w - len(net.nic[:10]) - 14 + i, y-1] for i in range(4)]
       
       
    2:                         out_misc += (f'{Mv.to(y-1, x+w - 25)}{THEME.net_box}{Symbol.h_line * (10 - len(net.nic[:10]))}{Symbol.title_left}{Fx.b if reset else ""}{THEME.hi_fg("z")}{THEME.title("ero")}'
                                       f'{Fx.ub}{THEME.net_box(Symbol.title_right)}{Term.fg}'
                                       f'{THEME.net_box}{Symbol.title_left}{Fx.b}{THEME.hi_fg("<b")} {THEME.title(net.nic[:10])} {THEME.hi_fg("n>")}{Fx.ub}{THEME.net_box(Symbol.title_right)}{Term.fg}')
    2:                         if w - len(net.nic[:10]) - 20 > 6:
   12:                                 Key.mouse["a"] = [[x+w - 20 - len(net.nic[:10]) + i, y-1] for i in range(4)]
    2:                                 out_misc += (f'{Mv.to(y-1, x+w - 21 - len(net.nic[:10]))}{THEME.net_box(Symbol.title_left)}{Fx.b if net.auto_min else ""}{THEME.hi_fg("a")}{THEME.title("uto")}'
                                       f'{Fx.ub}{THEME.net_box(Symbol.title_right)}{Term.fg}')
    2:                         if w - len(net.nic[:10]) - 20 > 13:
   12:                                 Key.mouse["y"] = [[x+w - 26 - len(net.nic[:10]) + i, y-1] for i in range(4)]
    2:                                 out_misc += (f'{Mv.to(y-1, x+w - 27 - len(net.nic[:10]))}{THEME.net_box(Symbol.title_left)}{Fx.b if CONFIG.net_sync else ""}{THEME.title("s")}{THEME.hi_fg("y")}{THEME.title("nc")}'
                                       f'{Fx.ub}{THEME.net_box(Symbol.title_right)}{Term.fg}')
    2:                         if net.address and w - len(net.nic[:10]) - len(net.address) - 20 > 15:
    2:                                 out_misc += (f'{Mv.to(y-1, x+7)}{THEME.net_box(Symbol.title_left)}{Fx.b}{THEME.title(net.address)}{Fx.ub}{THEME.net_box(Symbol.title_right)}{Term.fg}')
    2:                         Draw.buffer("net_misc", out_misc, only_save=True)
       
    2:                 cy = 0
    6:                 for direction in ["download", "upload"]:
    4:                         strings = net.strings[net.nic][direction]
    4:                         stats = net.stats[net.nic][direction]
    4:                         if cls.redraw: stats["redraw"] = True
    4:                         if stats["redraw"] or cls.resized:
    8:                                 Graphs.net[direction] = Graph(w - bw - 3, cls.graph_height[direction], THEME.gradient[direction], stats["speed"], max_value=net.sync_top if CONFIG.net_sync else stats["graph_top"],
    4:                                         invert=direction != "download", color_max_value=net.net_min.get(direction) if CONFIG.net_color_fixed else None, round_up_low=True)
    4:                         out += f'{Mv.to(y if direction == "download" else y + cls.graph_height["download"], x)}{Graphs.net[direction](None if stats["redraw"] else stats["speed"][-1])}'
       
    8:                         out += (f'{Mv.to(by+cy, bx)}{THEME.main_fg}{cls.symbols[direction]} {strings["byte_ps"]:<10.10}' +
    4:                                         ("" if bw < 20 else f'{Mv.to(by+cy, bx+bw - 12)}{"(" + strings["bit_ps"] + ")":>12.12}'))
    4:                         cy += 1 if bh != 3 else 2
    4:                         if bh >= 6:
                                       out += f'{Mv.to(by+cy, bx)}{cls.symbols[direction]} {"Top:"}{Mv.to(by+cy, bx+bw - 12)}{"(" + strings["top"] + ")":>12.12}'
                                       cy += 1
    4:                         if bh >= 4:
    4:                                 out += f'{Mv.to(by+cy, bx)}{cls.symbols[direction]} {"Total:"}{Mv.to(by+cy, bx+bw - 10)}{strings["total"]:>10.10}'
    4:                                 if bh > 2 and bh % 2: cy += 2
    4:                                 else: cy += 1
    4:                         stats["redraw"] = False
       
    2:                 out += (f'{Mv.to(y, x)}{THEME.graph_text(net.sync_string if CONFIG.net_sync else net.strings[net.nic]["download"]["graph_top"])}'
                                       f'{Mv.to(y+h-1, x)}{THEME.graph_text(net.sync_string if CONFIG.net_sync else net.strings[net.nic]["upload"]["graph_top"])}')
       
    2:                 Draw.buffer(cls.buffer, f'{out_misc}{out}{Term.fg}', only_save=Menu.active)
    2:                 cls.redraw = cls.resized = False
       
    2: class ProcBox(Box):
    1:         name = "proc"
    1:         num = 4
    1:         height_p = 68
    1:         width_p = 55
    1:         min_w: int = 44
    1:         min_h: int = 16
    1:         x = 1
    1:         y = 1
    1:         current_y: int = 0
    1:         current_h: int = 0
    1:         select_max: int = 0
    1:         selected: int = 0
    1:         selected_pid: int = 0
    1:         last_selection: int = 0
    1:         filtering: bool = False
    1:         moved: bool = False
    1:         start: int = 1
    1:         count: int = 0
    1:         s_len: int = 0
    1:         detailed: bool = False
    1:         detailed_x: int = 0
    1:         detailed_y: int = 0
    1:         detailed_width: int = 0
    1:         detailed_height: int = 8
    1:         resized: bool = True
    1:         redraw: bool = True
    1:         buffer: str = "proc"
    1:         pid_counter: Dict[int, int] = {}
    1:         Box.buffers.append(buffer)
       
    1:         @classmethod
    1:         def _calc_size(cls):
    2:                 if not "proc" in cls.boxes:
    2:                         cls.width = Term.width
    2:                         return
                       width_p: int; height_p: int
                       if not "net" in cls.boxes and not "mem" in cls.boxes:
                               width_p = 100
                       else:
                               width_p = cls.width_p
       
                       if not "cpu" in cls.boxes:
                               height_p = 100
                       else:
                               height_p = cls.height_p
       
                       cls.width = round(Term.width * width_p / 100)
                       cls.height = round(Term.height * height_p / 100)
                       if cls.height + Box._b_cpu_h > Term.height: cls.height = Term.height - Box._b_cpu_h
                       cls.x = Term.width - cls.width + 1
                       cls.y = Box._b_cpu_h + 1
                       cls.current_y = cls.y
                       cls.current_h = cls.height
                       cls.select_max = cls.height - 3
                       cls.redraw = True
                       cls.resized = True
       
    1:         @classmethod
    1:         def _draw_bg(cls) -> str:
    2:                 if not "proc" in cls.boxes: return ""
                       return create_box(box=cls, line_color=THEME.proc_box)
       
    1:         @classmethod
    1:         def selector(cls, key: str, mouse_pos: Tuple[int, int] = (0, 0)):
                       old: Tuple[int, int] = (cls.start, cls.selected)
                       new_sel: int
                       if key in ["up", "k"]:
                               if cls.selected == 1 and cls.start > 1:
                                       cls.start -= 1
                               elif cls.selected == 1:
                                       cls.selected = 0
                               elif cls.selected > 1:
                                       cls.selected -= 1
                       elif key in ["down", "j"]:
                               if cls.selected == 0 and ProcCollector.detailed and cls.last_selection:
                                       cls.selected = cls.last_selection
                                       cls.last_selection = 0
                               if cls.selected == cls.select_max and cls.start < ProcCollector.num_procs - cls.select_max + 1:
                                       cls.start += 1
                               elif cls.selected < cls.select_max:
                                       cls.selected += 1
                       elif key == "mouse_scroll_up" and cls.start > 1:
                               cls.start -= 5
                       elif key == "mouse_scroll_down" and cls.start < ProcCollector.num_procs - cls.select_max + 1:
                               cls.start += 5
                       elif key == "page_up" and cls.start > 1:
                               cls.start -= cls.select_max
                       elif key == "page_down" and cls.start < ProcCollector.num_procs - cls.select_max + 1:
                               cls.start += cls.select_max
                       elif key == "home":
                               if cls.start > 1: cls.start = 1
                               elif cls.selected > 0: cls.selected = 0
                       elif key == "end":
                               if cls.start < ProcCollector.num_procs - cls.select_max + 1: cls.start = ProcCollector.num_procs - cls.select_max + 1
                               elif cls.selected < cls.select_max: cls.selected = cls.select_max
                       elif key == "mouse_click":
                               if mouse_pos[0] > cls.x + cls.width - 4 and cls.current_y + 1 < mouse_pos[1] < cls.current_y + 1 + cls.select_max + 1:
                                       if mouse_pos[1] == cls.current_y + 2:
                                               cls.start = 1
                                       elif mouse_pos[1] == cls.current_y + 1 + cls.select_max:
                                               cls.start = ProcCollector.num_procs - cls.select_max + 1
                                       else:
                                               cls.start = round((mouse_pos[1] - cls.current_y) * ((ProcCollector.num_procs - cls.select_max - 2) / (cls.select_max - 2)))
                               else:
                                       new_sel = mouse_pos[1] - cls.current_y - 1 if mouse_pos[1] >= cls.current_y - 1 else 0
                                       if new_sel > 0 and new_sel == cls.selected:
                                               Key.list.insert(0, "enter")
                                               return
                                       elif new_sel > 0 and new_sel != cls.selected:
                                               if cls.last_selection: cls.last_selection = 0
                                               cls.selected = new_sel
                       elif key == "mouse_unselect":
                               cls.selected = 0
       
                       if cls.start > ProcCollector.num_procs - cls.select_max + 1 and ProcCollector.num_procs > cls.select_max: cls.start = ProcCollector.num_procs - cls.select_max + 1
                       elif cls.start > ProcCollector.num_procs: cls.start = ProcCollector.num_procs
                       if cls.start < 1: cls.start = 1
                       if cls.selected > ProcCollector.num_procs and ProcCollector.num_procs < cls.select_max: cls.selected = ProcCollector.num_procs
                       elif cls.selected > cls.select_max: cls.selected = cls.select_max
                       if cls.selected < 0: cls.selected = 0
       
                       if old != (cls.start, cls.selected):
                               cls.moved = True
                               Collector.collect(ProcCollector, proc_interrupt=True, redraw=True, only_draw=True)
       
       
    1:         @classmethod
    1:         def _draw_fg(cls):
    2:                 if not "proc" in cls.boxes: return
                       proc = ProcCollector
                       if proc.proc_interrupt: return
                       if proc.redraw: cls.redraw = True
                       out: str = ""
                       out_misc: str = ""
                       n: int = 0
                       x, y, w, h = cls.x + 1, cls.current_y + 1, cls.width - 2, cls.current_h - 2
                       prog_len: int; arg_len: int; val: int; c_color: str; m_color: str; t_color: str; sort_pos: int; tree_len: int; is_selected: bool; calc: int
                       dgx: int; dgw: int; dx: int; dw: int; dy: int
                       l_count: int = 0
                       scroll_pos: int = 0
                       killed: bool = True
                       indent: str = ""
                       offset: int = 0
                       tr_show: bool = True
                       usr_show: bool = True
                       vals: List[str]
                       g_color: str = ""
                       s_len: int = 0
                       if proc.search_filter: s_len = len(proc.search_filter[:10])
                       loc_string: str = f'{cls.start + cls.selected - 1}/{proc.num_procs}'
                       end: str = ""
       
                       if proc.detailed:
                               dgx, dgw = x, w // 3
                               dw = w - dgw - 1
                               if dw > 120:
                                       dw = 120
                                       dgw = w - 121
                               dx = x + dgw + 2
                               dy = cls.y + 1
       
                       if w > 67:
                               arg_len = w - 53 - (1 if proc.num_procs > cls.select_max else 0)
                               prog_len = 15
                       else:
                               arg_len = 0
                               prog_len = w - 38 - (1 if proc.num_procs > cls.select_max else 0)
                               if prog_len < 15:
                                       tr_show = False
                                       prog_len += 5
                               if prog_len < 12:
                                       usr_show = False
                                       prog_len += 9
       
                       if CONFIG.proc_tree:
                               tree_len = arg_len + prog_len + 6
                               arg_len = 0
       
                       #* Buttons and titles only redrawn if needed
                       if cls.resized or cls.redraw:
                               s_len += len(CONFIG.proc_sorting)
                               if cls.resized or s_len != cls.s_len or proc.detailed:
                                       cls.s_len = s_len
                                       for k in ["e", "r", "c", "T", "K", "I", "enter", "left", " ", "f", "delete"]:
                                               if k in Key.mouse: del Key.mouse[k]
                               if proc.detailed:
                                       killed = proc.details.get("killed", False)
                                       main = THEME.main_fg if cls.selected == 0 and not killed else THEME.inactive_fg
                                       hi = THEME.hi_fg if cls.selected == 0 and not killed else THEME.inactive_fg
                                       title = THEME.title if cls.selected == 0 and not killed else THEME.inactive_fg
                                       if cls.current_y != cls.y + 8 or cls.resized or Graphs.detailed_cpu is NotImplemented:
                                               cls.current_y = cls.y + 8
                                               cls.current_h = cls.height - 8
                                               for i in range(7): out_misc += f'{Mv.to(dy+i, x)}{" " * w}'
                                               out_misc += (f'{Mv.to(dy+7, x-1)}{THEME.proc_box}{Symbol.title_right}{Symbol.h_line*w}{Symbol.title_left}'
                                               f'{Mv.to(dy+7, x+1)}{THEME.proc_box(Symbol.title_left)}{Fx.b}{THEME.hi_fg(SUPERSCRIPT[cls.num])}{THEME.title(cls.name)}{Fx.ub}{THEME.proc_box(Symbol.title_right)}{THEME.div_line}')
                                               for i in range(7):
                                                       out_misc += f'{Mv.to(dy + i, dgx + dgw + 1)}{Symbol.v_line}'
       
                                       out_misc += (f'{Mv.to(dy-1, x-1)}{THEME.proc_box}{Symbol.left_up}{Symbol.h_line*w}{Symbol.right_up}'
                                               f'{Mv.to(dy-1, dgx + dgw + 1)}{Symbol.div_up}'
                                               f'{Mv.to(dy-1, x+1)}{THEME.proc_box(Symbol.title_left)}{Fx.b}{THEME.title(str(proc.details["pid"]))}{Fx.ub}{THEME.proc_box(Symbol.title_right)}'
                                               f'{THEME.proc_box(Symbol.title_left)}{Fx.b}{THEME.title(proc.details["name"][:(dgw - 11)])}{Fx.ub}{THEME.proc_box(Symbol.title_right)}')
       
                                       if cls.selected == 0:
                                               Key.mouse["enter"] = [[dx+dw-10 + i, dy-1] for i in range(7)]
                                       if cls.selected == 0 and not killed:
                                               Key.mouse["T"] = [[dx+2 + i, dy-1] for i in range(9)]
       
                                       out_misc += (f'{Mv.to(dy-1, dx+dw - 11)}{THEME.proc_box(Symbol.title_left)}{Fx.b}{title if cls.selected > 0 else THEME.title}close{Fx.ub} {main if cls.selected > 0 else THEME.main_fg}{Symbol.enter}{THEME.proc_box(Symbol.title_right)}'
                                               f'{Mv.to(dy-1, dx+1)}{THEME.proc_box(Symbol.title_left)}{Fx.b}{hi}T{title}erminate{Fx.ub}{THEME.proc_box(Symbol.title_right)}')
                                       if dw > 28:
                                               if cls.selected == 0 and not killed and not "K" in Key.mouse: Key.mouse["K"] = [[dx + 13 + i, dy-1] for i in range(4)]
                                               out_misc += f'{THEME.proc_box(Symbol.title_left)}{Fx.b}{hi}K{title}ill{Fx.ub}{THEME.proc_box(Symbol.title_right)}'
                                       if dw > 39:
                                               if cls.selected == 0 and not killed and not "I" in Key.mouse: Key.mouse["I"] = [[dx + 19 + i, dy-1] for i in range(9)]
                                               out_misc += f'{THEME.proc_box(Symbol.title_left)}{Fx.b}{hi}I{title}nterrupt{Fx.ub}{THEME.proc_box(Symbol.title_right)}'
       
                                       if Graphs.detailed_cpu is NotImplemented or cls.resized:
                                               Graphs.detailed_cpu = Graph(dgw+1, 7, THEME.gradient["cpu"], proc.details_cpu)
                                               Graphs.detailed_mem = Graph(dw // 3, 1, None, proc.details_mem)
       
                                       cls.select_max = cls.height - 11
                                       y = cls.y + 9
                                       h = cls.height - 10
       
                               else:
                                       if cls.current_y != cls.y or cls.resized:
                                               cls.current_y = cls.y
                                               cls.current_h = cls.height
                                               y, h = cls.y + 1, cls.height - 2
                                               out_misc += (f'{Mv.to(y-1, x-1)}{THEME.proc_box}{Symbol.left_up}{Symbol.h_line*w}{Symbol.right_up}'
                                                       f'{Mv.to(y-1, x+1)}{THEME.proc_box(Symbol.title_left)}{Fx.b}{THEME.hi_fg(SUPERSCRIPT[cls.num])}{THEME.title(cls.name)}{Fx.ub}{THEME.proc_box(Symbol.title_right)}'
                                                       f'{Mv.to(y+7, x-1)}{THEME.proc_box(Symbol.v_line)}{Mv.r(w)}{THEME.proc_box(Symbol.v_line)}')
                                       cls.select_max = cls.height - 3
       
       
                               sort_pos = x + w - len(CONFIG.proc_sorting) - 7
                               if not "left" in Key.mouse:
                                       Key.mouse["left"] = [[sort_pos + i, y-1] for i in range(3)]
                                       Key.mouse["right"] = [[sort_pos + len(CONFIG.proc_sorting) + 3 + i, y-1] for i in range(3)]
       
       
                               out_misc += (f'{Mv.to(y-1, x + 8)}{THEME.proc_box(Symbol.h_line * (w - 9))}' +
                                       ("" if not proc.detailed else f"{Mv.to(dy+7, dgx + dgw + 1)}{THEME.proc_box(Symbol.div_down)}") +
                                       f'{Mv.to(y-1, sort_pos)}{THEME.proc_box(Symbol.title_left)}{Fx.b}{THEME.hi_fg("<")} {THEME.title(CONFIG.proc_sorting)} '
                                       f'{THEME.hi_fg(">")}{Fx.ub}{THEME.proc_box(Symbol.title_right)}')
       
       
                               if w > 29 + s_len:
                                       if not "e" in Key.mouse: Key.mouse["e"] = [[sort_pos - 5 + i, y-1] for i in range(4)]
                                       out_misc += (f'{Mv.to(y-1, sort_pos - 6)}{THEME.proc_box(Symbol.title_left)}{Fx.b if CONFIG.proc_tree else ""}'
                                               f'{THEME.title("tre")}{THEME.hi_fg("e")}{Fx.ub}{THEME.proc_box(Symbol.title_right)}')
                               if w > 37 + s_len:
                                       if not "r" in Key.mouse: Key.mouse["r"] = [[sort_pos - 14 + i, y-1] for i in range(7)]
                                       out_misc += (f'{Mv.to(y-1, sort_pos - 15)}{THEME.proc_box(Symbol.title_left)}{Fx.b if CONFIG.proc_reversed else ""}'
                                               f'{THEME.hi_fg("r")}{THEME.title("everse")}{Fx.ub}{THEME.proc_box(Symbol.title_right)}')
                               if w > 47 + s_len:
                                       if not "c" in Key.mouse: Key.mouse["c"] = [[sort_pos - 24 + i, y-1] for i in range(8)]
                                       out_misc += (f'{Mv.to(y-1, sort_pos - 25)}{THEME.proc_box(Symbol.title_left)}{Fx.b if CONFIG.proc_per_core else ""}'
                                               f'{THEME.title("per-")}{THEME.hi_fg("c")}{THEME.title("ore")}{Fx.ub}{THEME.proc_box(Symbol.title_right)}')
       
                               if not "f" in Key.mouse or cls.resized: Key.mouse["f"] = [[x+6 + i, y-1] for i in range(6 if not proc.search_filter else 2 + len(proc.search_filter[-10:]))]
                               if proc.search_filter:
                                       if not "delete" in Key.mouse: Key.mouse["delete"] = [[x+12 + len(proc.search_filter[-10:]) + i, y-1] for i in range(3)]
                               elif "delete" in Key.mouse:
                                       del Key.mouse["delete"]
                               out_misc += (f'{Mv.to(y-1, x + 8)}{THEME.proc_box(Symbol.title_left)}{Fx.b if cls.filtering or proc.search_filter else ""}{THEME.hi_fg("F" if cls.filtering and proc.case_sensitive else "f")}{THEME.title}' +
                                       ("ilter" if not proc.search_filter and not cls.filtering else f' {proc.search_filter[-(10 if w < 83 else w - 74):]}{(Fx.bl + "█" + Fx.ubl) if cls.filtering else THEME.hi_fg(" del")}') +
                                       f'{THEME.proc_box(Symbol.title_right)}')
       
                               main = THEME.inactive_fg if cls.selected == 0 else THEME.main_fg
                               hi = THEME.inactive_fg if cls.selected == 0 else THEME.hi_fg
                               title = THEME.inactive_fg if cls.selected == 0 else THEME.title
                               out_misc += (f'{Mv.to(y+h, x + 1)}{THEME.proc_box}{Symbol.h_line*(w-4)}'
                                               f'{Mv.to(y+h, x+1)}{THEME.proc_box(Symbol.title_left)}{main}{Symbol.up} {Fx.b}{THEME.main_fg("select")} {Fx.ub}'
                                               f'{THEME.inactive_fg if cls.selected == cls.select_max else THEME.main_fg}{Symbol.down}{THEME.proc_box(Symbol.title_right)}'
                                               f'{THEME.proc_box(Symbol.title_left)}{title}{Fx.b}info {Fx.ub}{main}{Symbol.enter}{THEME.proc_box(Symbol.title_right)}')
                               if not "enter" in Key.mouse: Key.mouse["enter"] = [[x + 14 + i, y+h] for i in range(6)]
                               if w - len(loc_string) > 34:
                                       if not "T" in Key.mouse: Key.mouse["T"] = [[x + 22 + i, y+h] for i in range(9)]
                                       out_misc += f'{THEME.proc_box(Symbol.title_left)}{Fx.b}{hi}T{title}erminate{Fx.ub}{THEME.proc_box(Symbol.title_right)}'
                               if w - len(loc_string) > 40:
                                       if not "K" in Key.mouse: Key.mouse["K"] = [[x + 33 + i, y+h] for i in range(4)]
                                       out_misc += f'{THEME.proc_box(Symbol.title_left)}{Fx.b}{hi}K{title}ill{Fx.ub}{THEME.proc_box(Symbol.title_right)}'
                               if w - len(loc_string) > 51:
                                       if not "I" in Key.mouse: Key.mouse["I"] = [[x + 39 + i, y+h] for i in range(9)]
                                       out_misc += f'{THEME.proc_box(Symbol.title_left)}{Fx.b}{hi}I{title}nterrupt{Fx.ub}{THEME.proc_box(Symbol.title_right)}'
                               if CONFIG.proc_tree and w - len(loc_string) > 65:
                                       if not " " in Key.mouse: Key.mouse[" "] = [[x + 50 + i, y+h] for i in range(12)]
                                       out_misc += f'{THEME.proc_box(Symbol.title_left)}{Fx.b}{hi}spc {title}collapse{Fx.ub}{THEME.proc_box(Symbol.title_right)}'
       
                               #* Processes labels
                               selected: str = CONFIG.proc_sorting
                               label: str
                               if selected == "memory": selected = "mem"
                               if selected == "threads" and not CONFIG.proc_tree and not arg_len: selected = "tr"
                               if CONFIG.proc_tree:
                                       label = (f'{THEME.title}{Fx.b}{Mv.to(y, x)}{" Tree:":<{tree_len-2}}' + (f'{"Threads: ":<9}' if tr_show else " "*4) + (f'{"User:":<9}' if usr_show else "") + f'Mem%{"Cpu%":>11}{Fx.ub}{THEME.main_fg} ' +
                                                       (" " if proc.num_procs > cls.select_max else ""))
                                       if selected in ["pid", "program", "arguments"]: selected = "tree"
                               else:
                                       label = (f'{THEME.title}{Fx.b}{Mv.to(y, x)}{"Pid:":>7} {"Program:" if prog_len > 8 else "Prg:":<{prog_len}}' + (f'{"Arguments:":<{arg_len-4}}' if arg_len else "") +
                                               ((f'{"Threads:":<9}' if arg_len else f'{"Tr:":^5}') if tr_show else "") + (f'{"User:":<9}' if usr_show else "") + f'Mem%{"Cpu%":>11}{Fx.ub}{THEME.main_fg} ' +
                                               (" " if proc.num_procs > cls.select_max else ""))
                                       if selected == "program" and prog_len <= 8: selected = "prg"
                               selected = selected.split(" ")[0].capitalize()
                               if CONFIG.proc_mem_bytes: label = label.replace("Mem%", "MemB")
                               label = label.replace(selected, f'{Fx.u}{selected}{Fx.uu}')
                               out_misc += label
       
                               Draw.buffer("proc_misc", out_misc, only_save=True)
       
                       #* Detailed box draw
                       if proc.detailed:
                               if proc.details["status"] == psutil.STATUS_RUNNING: stat_color = Fx.b
                               elif proc.details["status"] in [psutil.STATUS_DEAD, psutil.STATUS_STOPPED, psutil.STATUS_ZOMBIE]: stat_color = f'{THEME.inactive_fg}'
                               else: stat_color = ""
                               expand = proc.expand
                               iw = (dw - 3) // (4 + expand)
                               iw2 = iw - 1
                               out += (f'{Mv.to(dy, dgx)}{Graphs.detailed_cpu(None if cls.moved or proc.details["killed"] else proc.details_cpu[-1])}'
                                               f'{Mv.to(dy, dgx)}{THEME.title}{Fx.b}{0 if proc.details["killed"] else proc.details["cpu_percent"]}%{Mv.r(1)}{"" if SYSTEM == "MacOS" else (("C" if dgw < 20 else "Core") + str(proc.details["cpu_num"]))}')
                               for i, l in enumerate(["C", "P", "U"]):
                                       out += f'{Mv.to(dy+2+i, dgx)}{l}'
                               for i, l in enumerate(["C", "M", "D"]):
                                       out += f'{Mv.to(dy+4+i, dx+1)}{l}'
                               out += (f'{Mv.to(dy, dx+1)} {"Status:":^{iw}.{iw2}}{"Elapsed:":^{iw}.{iw2}}' +
                                               (f'{"Parent:":^{iw}.{iw2}}' if dw > 28 else "") + (f'{"User:":^{iw}.{iw2}}' if dw > 38 else "") +
                                               (f'{"Threads:":^{iw}.{iw2}}' if expand > 0 else "") + (f'{"Nice:":^{iw}.{iw2}}' if expand > 1 else "") +
                                               (f'{"IO Read:":^{iw}.{iw2}}' if expand > 2 else "") + (f'{"IO Write:":^{iw}.{iw2}}' if expand > 3 else "") +
                                               (f'{"TTY:":^{iw}.{iw2}}' if expand > 4 else "") +
                                               f'{Mv.to(dy+1, dx+1)}{Fx.ub}{THEME.main_fg}{stat_color}{proc.details["status"]:^{iw}.{iw2}}{Fx.ub}{THEME.main_fg}{proc.details["uptime"]:^{iw}.{iw2}} ' +
                                               (f'{proc.details["parent_name"]:^{iw}.{iw2}}' if dw > 28 else "") + (f'{proc.details["username"]:^{iw}.{iw2}}' if dw > 38 else "") +
                                               (f'{proc.details["threads"]:^{iw}.{iw2}}' if expand > 0 else "") + (f'{proc.details["nice"]:^{iw}.{iw2}}' if expand > 1 else "") +
                                               (f'{proc.details["io_read"]:^{iw}.{iw2}}' if expand > 2 else "") + (f'{proc.details["io_write"]:^{iw}.{iw2}}' if expand > 3 else "") +
                                               (f'{proc.details["terminal"][-(iw2):]:^{iw}.{iw2}}' if expand > 4 else "") +
                                               f'{Mv.to(dy+3, dx)}{THEME.title}{Fx.b}{("Memory: " if dw > 42 else "M:") + str(round(proc.details["memory_percent"], 1)) + "%":>{dw//3-1}}{Fx.ub} {THEME.inactive_fg}{"⡀"*(dw//3)}'
                                               f'{Mv.l(dw//3)}{THEME.proc_misc}{Graphs.detailed_mem(None if cls.moved else proc.details_mem[-1])} '
                                               f'{THEME.title}{Fx.b}{proc.details["memory_bytes"]:.{dw//3 - 2}}{THEME.main_fg}{Fx.ub}')
                               cy = dy + (4 if len(proc.details["cmdline"]) > dw - 5 else 5)
                               for i in range(ceil(len(proc.details["cmdline"]) / (dw - 5))):
                                       out += f'{Mv.to(cy+i, dx + 3)}{proc.details["cmdline"][((dw-5)*i):][:(dw-5)]:{"^" if i == 0 else "<"}{dw-5}}'
                                       if i == 2: break
       
                       #* Checking for selection out of bounds
                       if cls.start > proc.num_procs - cls.select_max + 1 and proc.num_procs > cls.select_max: cls.start = proc.num_procs - cls.select_max + 1
                       elif cls.start > proc.num_procs: cls.start = proc.num_procs
                       if cls.start < 1: cls.start = 1
                       if cls.selected > proc.num_procs and proc.num_procs < cls.select_max: cls.selected = proc.num_procs
                       elif cls.selected > cls.select_max: cls.selected = cls.select_max
                       if cls.selected < 0: cls.selected = 0
       
                       #* Start iteration over all processes and info
                       cy = 1
                       for n, (pid, items) in enumerate(proc.processes.items(), start=1):
                               if n < cls.start: continue
                               l_count += 1
                               if l_count == cls.selected:
                                       is_selected = True
                                       cls.selected_pid = pid
                               else: is_selected = False
       
                               indent, name, cmd, threads, username, mem, mem_b, cpu = [items.get(v, d) for v, d in [("indent", ""), ("name", ""), ("cmd", ""), ("threads", 0), ("username", "?"), ("mem", 0.0), ("mem_b", 0), ("cpu", 0.0)]]
       
                               if CONFIG.proc_tree:
                                       arg_len = 0
                                       offset = tree_len - len(f'{indent}{pid}')
                                       if offset < 1: offset = 0
                                       indent = f'{indent:.{tree_len - len(str(pid))}}'
                                       if offset - len(name) > 12:
                                               cmd = cmd.split(" ")[0].split("/")[-1]
                                               if not cmd.startswith(name):
                                                       offset = len(name)
                                                       arg_len = tree_len - len(f'{indent}{pid} {name} ') + 2
                                                       cmd = f'({cmd[:(arg_len-4)]})'
                               else:
                                       offset = prog_len - 1
                               if cpu > 1.0 or pid in Graphs.pid_cpu:
                                       if pid not in Graphs.pid_cpu:
                                               Graphs.pid_cpu[pid] = Graph(5, 1, None, [0])
                                               cls.pid_counter[pid] = 0
                                       elif cpu < 1.0:
                                               cls.pid_counter[pid] += 1
                                               if cls.pid_counter[pid] > 10:
                                                       del cls.pid_counter[pid], Graphs.pid_cpu[pid]
                                       else:
                                               cls.pid_counter[pid] = 0
       
                               end = f'{THEME.main_fg}{Fx.ub}' if CONFIG.proc_colors else Fx.ub
                               if cls.selected > cy: calc = cls.selected - cy
                               elif 0 < cls.selected <= cy: calc = cy - cls.selected
                               else: calc = cy
                               if CONFIG.proc_colors and not is_selected:
                                       vals = []
                                       for v in [int(cpu), int(mem), int(threads // 3)]:
                                               if CONFIG.proc_gradient:
                                                       val = ((v if v <= 100 else 100) + 100) - calc * 100 // cls.select_max
                                                       vals += [f'{THEME.gradient["proc_color" if val < 100 else "process"][val if val < 100 else val - 100]}']
                                               else:
                                                       vals += [f'{THEME.gradient["process"][v if v <= 100 else 100]}']
                                       c_color, m_color, t_color = vals
                               else:
                                       c_color = m_color = t_color = Fx.b
                               if CONFIG.proc_gradient and not is_selected:
                                       g_color = f'{THEME.gradient["proc"][calc * 100 // cls.select_max]}'
                               if is_selected:
                                       c_color = m_color = t_color = g_color = end = ""
                                       out += f'{THEME.selected_bg}{THEME.selected_fg}{Fx.b}'
       
                               #* Creates one line for a process with all gathered information
                               out += (f'{Mv.to(y+cy, x)}{g_color}{indent}{pid:>{(1 if CONFIG.proc_tree else 7)}} ' +
                                       f'{c_color}{name:<{offset}.{offset}} {end}' +
                                       (f'{g_color}{cmd:<{arg_len}.{arg_len-1}}' if arg_len else "") +
                                       (t_color + (f'{threads:>4} ' if threads < 1000 else "999> ") + end if tr_show else "") +
                                       (g_color + (f'{username:<9.9}' if len(username) < 10 else f'{username[:8]:<8}+') if usr_show else "") +
                                       m_color + ((f'{mem:>4.1f}' if mem < 100 else f'{mem:>4.0f} ') if not CONFIG.proc_mem_bytes else f'{floating_humanizer(mem_b, short=True):>4.4}') + end +
                                       f' {THEME.inactive_fg}{"⡀"*5}{THEME.main_fg}{g_color}{c_color}' + (f' {cpu:>4.1f} ' if cpu < 100 else f'{cpu:>5.0f} ') + end +
                                       (" " if proc.num_procs > cls.select_max else ""))
       
                               #* Draw small cpu graph for process if cpu usage was above 1% in the last 10 updates
                               if pid in Graphs.pid_cpu:
                                       out += f'{Mv.to(y+cy, x + w - (12 if proc.num_procs > cls.select_max else 11))}{c_color if CONFIG.proc_colors else THEME.proc_misc}{Graphs.pid_cpu[pid](None if cls.moved else round(cpu))}{THEME.main_fg}'
       
                               if is_selected: out += f'{Fx.ub}{Term.fg}{Term.bg}{Mv.to(y+cy, x + w - 1)}{" " if proc.num_procs > cls.select_max else ""}'
       
                               cy += 1
                               if cy == h: break
                       if cy < h:
                               for i in range(h-cy):
                                       out += f'{Mv.to(y+cy+i, x)}{" " * w}'
       
                       #* Draw scrollbar if needed
                       if proc.num_procs > cls.select_max:
                               if cls.resized:
                                       Key.mouse["mouse_scroll_up"] = [[x+w-2+i, y] for i in range(3)]
                                       Key.mouse["mouse_scroll_down"] = [[x+w-2+i, y+h-1] for i in range(3)]
                               scroll_pos = round(cls.start * (cls.select_max - 2) / (proc.num_procs - (cls.select_max - 2)))
                               if scroll_pos < 0 or cls.start == 1: scroll_pos = 0
                               elif scroll_pos > h - 3 or cls.start >= proc.num_procs - cls.select_max: scroll_pos = h - 3
                               out += (f'{Mv.to(y, x+w-1)}{Fx.b}{THEME.main_fg}↑{Mv.to(y+h-1, x+w-1)}↓{Fx.ub}'
                                               f'{Mv.to(y+1+scroll_pos, x+w-1)}█')
                       elif "scroll_up" in Key.mouse:
                               del Key.mouse["scroll_up"], Key.mouse["scroll_down"]
       
                       #* Draw current selection and number of processes
                       out += (f'{Mv.to(y+h, x + w - 3 - len(loc_string))}{THEME.proc_box}{Symbol.title_left}{THEME.title}'
                                               f'{Fx.b}{loc_string}{Fx.ub}{THEME.proc_box(Symbol.title_right)}')
       
                       #* Clean up dead processes graphs and counters
                       cls.count += 1
                       if cls.count == 100:
                               cls.count = 0
                               for p in list(cls.pid_counter):
                                       if not psutil.pid_exists(p):
                                               del cls.pid_counter[p], Graphs.pid_cpu[p]
       
                       Draw.buffer(cls.buffer, f'{out_misc}{out}{Term.fg}', only_save=Menu.active)
                       cls.redraw = cls.resized = cls.moved = False
       
    2: class Collector:
    1:         '''Data collector master class
               * .start(): Starts collector thread
               * .stop(): Stops collector thread
               * .collect(*collectors: Collector, draw_now: bool = True, interrupt: bool = False): queues up collectors to run'''
    1:         stopping: bool = False
    1:         started: bool = False
    1:         draw_now: bool = False
    1:         redraw: bool = False
    1:         only_draw: bool = False
    1:         thread: threading.Thread
    1:         collect_run = threading.Event()
    1:         collect_idle = threading.Event()
    1:         collect_idle.set()
    1:         collect_done = threading.Event()
    1:         collect_queue: List = []
    1:         collect_interrupt: bool = False
    1:         proc_interrupt: bool = False
    1:         use_draw_list: bool = False
    1:         proc_counter: int = 1
       
    1:         @classmethod
    1:         def start(cls):
    1:                 cls.stopping = False
    1:                 cls.thread = threading.Thread(target=cls._runner, args=())
    1:                 cls.thread.start()
    1:                 cls.started = True
       
    1:         @classmethod
    1:         def stop(cls):
    1:                 if cls.started and cls.thread.is_alive():
    1:                         cls.stopping = True
    1:                         cls.started = False
    1:                         cls.collect_queue = []
    1:                         cls.collect_idle.set()
    1:                         cls.collect_done.set()
    1:                         try:
    1:                                 cls.thread.join()
                               except:
                                       pass
       
    1:         @classmethod
    1:         def _runner(cls):
                       '''This is meant to run in it's own thread, collecting and drawing when collect_run is set'''
    1:                 draw_buffers: List[str] = []
    1:                 debugged: bool = False
    1:                 try:
   15:                         while not cls.stopping:
   14:                                 if CONFIG.draw_clock and CONFIG.update_ms != 1000: Box.draw_clock()
   14:                                 cls.collect_run.wait(0.1)
   14:                                 if not cls.collect_run.is_set():
   12:                                         continue
    2:                                 draw_buffers = []
    2:                                 cls.collect_interrupt = False
    2:                                 cls.collect_run.clear()
    2:                                 cls.collect_idle.clear()
    2:                                 cls.collect_done.clear()
    2:                                 if DEBUG and not debugged: TimeIt.start("Collect and draw")
   10:                                 while cls.collect_queue:
    8:                                         collector = cls.collect_queue.pop()
    8:                                         if not cls.only_draw:
    8:                                                 collector._collect()
    8:                                         collector._draw()
    8:                                         if cls.use_draw_list: draw_buffers.append(collector.buffer)
    8:                                         if cls.collect_interrupt: break
    2:                                 if DEBUG and not debugged: TimeIt.stop("Collect and draw"); debugged = True
    2:                                 if cls.draw_now and not Menu.active and not cls.collect_interrupt:
    1:                                         if cls.use_draw_list: Draw.out(*draw_buffers)
    1:                                         else: Draw.out()
    2:                                 if CONFIG.draw_clock and CONFIG.update_ms == 1000: Box.draw_clock()
    2:                                 cls.collect_idle.set()
    2:                                 cls.collect_done.set()
                       except Exception as e:
                               errlog.exception(f'Data collection thread failed with exception: {e}')
                               cls.collect_idle.set()
                               cls.collect_done.set()
                               clean_quit(1, thread=True)
       
    1:         @classmethod
    1:         def collect(cls, *collectors, draw_now: bool = True, interrupt: bool = False, proc_interrupt: bool = False, redraw: bool = False, only_draw: bool = False):
                       '''Setup collect queue for _runner'''
    2:                 cls.collect_interrupt = interrupt
    2:                 cls.proc_interrupt = proc_interrupt
    2:                 cls.collect_idle.wait()
    2:                 cls.collect_interrupt = False
    2:                 cls.proc_interrupt = False
    2:                 cls.use_draw_list = False
    2:                 cls.draw_now = draw_now
    2:                 cls.redraw = redraw
    2:                 cls.only_draw = only_draw
       
    2:                 if collectors:
                               cls.collect_queue = [*collectors]
                               cls.use_draw_list = True
                               if ProcCollector in cls.collect_queue:
                                       cls.proc_counter = 1
       
                       else:
    2:                         cls.collect_queue = list(cls.__subclasses__())
    2:                         if CONFIG.proc_update_mult > 1:
    2:                                 if cls.proc_counter > 1:
                                               cls.collect_queue.remove(ProcCollector)
    2:                                 if cls.proc_counter == CONFIG.proc_update_mult:
                                               cls.proc_counter = 0
    2:                                 cls.proc_counter += 1
       
    2:                 cls.collect_run.set()
       
       
    2: class CpuCollector(Collector):
    1:         '''Collects cpu usage for cpu and cores, cpu frequency, load_avg, uptime and cpu temps'''
    1:         cpu_usage: List[List[int]] = []
    1:         cpu_upper: List[int] = []
    1:         cpu_lower: List[int] = []
    1:         cpu_temp: List[List[int]] = []
    1:         cpu_temp_high: int = 0
    1:         cpu_temp_crit: int = 0
   10:         for _ in range(THREADS + 1):
    9:                 cpu_usage.append([])
    9:                 cpu_temp.append([])
    1:         freq_error: bool = False
    1:         cpu_freq: int = 0
    1:         load_avg: List[float] = []
    1:         uptime: str = ""
    1:         buffer: str = CpuBox.buffer
    1:         sensor_method: str = ""
    1:         got_sensors: bool = False
    1:         sensor_swap: bool = False
    1:         cpu_temp_only: bool = False
       
    1:         @classmethod
    1:         def get_sensors(cls):
                       '''Check if we can get cpu temps and return method of getting temps'''
    1:                 cls.sensor_method = ""
    1:                 if SYSTEM == "MacOS":
    1:                         try:
    1:                                 if which("coretemp") and subprocess.check_output(["coretemp", "-p"], universal_newlines=True).strip().replace("-", "").isdigit():
                                               cls.sensor_method = "coretemp"
    1:                                 elif which("osx-cpu-temp") and subprocess.check_output("osx-cpu-temp", universal_newlines=True).rstrip().endswith("°C"):
    1:                                         cls.sensor_method = "osx-cpu-temp"
                               except: pass
                       elif CONFIG.cpu_sensor != "Auto" and CONFIG.cpu_sensor in CONFIG.cpu_sensors:
                               cls.sensor_method = "psutil"
                       elif hasattr(psutil, "sensors_temperatures"):
                               try:
                                       temps = psutil.sensors_temperatures()
                                       if temps:
                                               for name, entries in temps.items():
                                                       if name.lower().startswith("cpu"):
                                                               cls.sensor_method = "psutil"
                                                               break
                                                       for entry in entries:
                                                               if entry.label.startswith(("Package", "Core 0", "Tdie", "CPU")):
                                                                       cls.sensor_method = "psutil"
                                                                       break
                               except: pass
    1:                 if not cls.sensor_method and SYSTEM == "Linux":
                               try:
                                       if which("vcgencmd") and subprocess.check_output(["vcgencmd", "measure_temp"], universal_newlines=True).strip().endswith("'C"):
                                               cls.sensor_method = "vcgencmd"
                               except: pass
    1:                 cls.got_sensors = bool(cls.sensor_method)
       
    1:         @classmethod
    1:         def _collect(cls):
    2:                 cls.cpu_usage[0].append(ceil(psutil.cpu_percent(percpu=False)))
    2:                 if len(cls.cpu_usage[0]) > Term.width * 4:
                               del cls.cpu_usage[0][0]
       
    2:                 cpu_times_percent = psutil.cpu_times_percent()
    6:                 for x in ["upper", "lower"]:
    4:                         if getattr(CONFIG, "cpu_graph_" + x) == "total":
    4:                                 setattr(cls, "cpu_" + x, cls.cpu_usage[0])
                               else:
                                       getattr(cls, "cpu_" + x).append(ceil(getattr(cpu_times_percent, getattr(CONFIG, "cpu_graph_" + x))))
    4:                         if len(getattr(cls, "cpu_" + x)) > Term.width * 4:
                                       del getattr(cls, "cpu_" + x)[0]
       
   18:                 for n, thread in enumerate(psutil.cpu_percent(percpu=True), start=1):
   16:                         cls.cpu_usage[n].append(ceil(thread))
   16:                         if len(cls.cpu_usage[n]) > Term.width * 2:
                                       del cls.cpu_usage[n][0]
    2:                 try:
    2:                         if CONFIG.show_cpu_freq and hasattr(psutil.cpu_freq(), "current"):
    2:                                 freq: float = psutil.cpu_freq().current
    2:                                 cls.cpu_freq = round(freq * (1 if freq > 10 else 1000))
                               elif cls.cpu_freq > 0:
                                       cls.cpu_freq = 0
                       except Exception as e:
                               if not cls.freq_error:
                                       cls.freq_error = True
                                       errlog.error("Exception while getting cpu frequency!")
                                       errlog.exception(f'{e}')
                               else:
                                       pass
   10:                 cls.load_avg = [round(lavg, 2) for lavg in psutil.getloadavg()]
    2:                 cls.uptime = str(timedelta(seconds=round(time()-psutil.boot_time(),0)))[:-3].replace(" days,", "d").replace(" day,", "d")
       
    2:                 if CONFIG.check_temp and cls.got_sensors:
    2:                         cls._collect_temps()
       
    1:         @classmethod
    1:         def _collect_temps(cls):
    2:                 temp: int = 1000
    2:                 cores: List[int] = []
    2:                 core_dict: Dict[int, int] = {}
    2:                 entry_int: int = 0
    2:                 cpu_type: str = ""
    2:                 c_max: int = 0
    2:                 s_name: str = "_-_"
    2:                 s_label: str = "_-_"
    2:                 if cls.sensor_method == "psutil":
                               try:
                                       if CONFIG.cpu_sensor != "Auto":
                                               s_name, s_label = CONFIG.cpu_sensor.split(":", 1)
                                       for name, entries in psutil.sensors_temperatures().items():
                                               for num, entry in enumerate(entries, 1):
                                                       if name == s_name and (entry.label == s_label or str(num) == s_label):
                                                               if entry.label.startswith("Package"):
                                                                       cpu_type = "intel"
                                                               elif entry.label.startswith("Tdie"):
                                                                       cpu_type = "ryzen"
                                                               else:
                                                                       cpu_type = "other"
                                                               if getattr(entry, "high", None) != None and entry.high > 1: cls.cpu_temp_high = round(entry.high)
                                                               else: cls.cpu_temp_high = 80
                                                               if getattr(entry, "critical", None) != None and entry.critical > 1: cls.cpu_temp_crit = round(entry.critical)
                                                               else: cls.cpu_temp_crit = 95
                                                               temp = round(entry.current)
                                                       elif entry.label.startswith(("Package", "Tdie")) and cpu_type in ["", "other"] and s_name == "_-_" and hasattr(entry, "current"):
                                                               if not cls.cpu_temp_high or cls.sensor_swap or cpu_type == "other":
                                                                       cls.sensor_swap = False
                                                                       if getattr(entry, "high", None) != None and entry.high > 1: cls.cpu_temp_high = round(entry.high)
                                                                       else: cls.cpu_temp_high = 80
                                                                       if getattr(entry, "critical", None) != None and entry.critical > 1: cls.cpu_temp_crit = round(entry.critical)
                                                                       else: cls.cpu_temp_crit = 95
                                                               cpu_type = "intel" if entry.label.startswith("Package") else "ryzen"
                                                               temp = round(entry.current)
                                                       elif (entry.label.startswith(("Core", "Tccd", "CPU")) or (name.lower().startswith("cpu") and not entry.label)) and hasattr(entry, "current"):
                                                               if entry.label.startswith(("Core", "Tccd")):
                                                                       entry_int = int(entry.label.replace("Core", "").replace("Tccd", ""))
                                                                       if entry_int in core_dict and cpu_type != "ryzen":
                                                                               if c_max == 0:
                                                                                       c_max = max(core_dict) + 1
                                                                               if c_max < THREADS // 2 and (entry_int + c_max) not in core_dict:
                                                                                       core_dict[(entry_int + c_max)] = round(entry.current)
                                                                               continue
                                                                       elif entry_int in core_dict:
                                                                               continue
                                                                       core_dict[entry_int] = round(entry.current)
                                                                       continue
                                                               elif cpu_type in ["intel", "ryzen"]:
                                                                       continue
                                                               if not cpu_type:
                                                                       cpu_type = "other"
                                                                       if not cls.cpu_temp_high or cls.sensor_swap:
                                                                               cls.sensor_swap = False
                                                                               if getattr(entry, "high", None) != None and entry.high > 1: cls.cpu_temp_high = round(entry.high)
                                                                               else: cls.cpu_temp_high = 60 if name == "cpu_thermal" else 80
                                                                               if getattr(entry, "critical", None) != None and entry.critical > 1: cls.cpu_temp_crit = round(entry.critical)
                                                                               else: cls.cpu_temp_crit = 80 if name == "cpu_thermal" else 95
                                                                       temp = round(entry.current)
                                                               cores.append(round(entry.current))
                                       if core_dict:
                                               if not temp or temp == 1000:
                                                       temp = sum(core_dict.values()) // len(core_dict)
                                               if not cls.cpu_temp_high or not cls.cpu_temp_crit:
                                                       cls.cpu_temp_high, cls.cpu_temp_crit = 80, 95
                                               cls.cpu_temp[0].append(temp)
                                               if cpu_type == "ryzen":
                                                       ccds: int = len(core_dict)
                                                       cores_per_ccd: int = CORES // ccds
                                                       z: int = 1
                                                       for x in range(THREADS):
                                                               if x == CORES:
                                                                       z = 1
                                                               if CORE_MAP[x] + 1 > cores_per_ccd * z:
                                                                       z += 1
                                                               if z in core_dict:
                                                                       cls.cpu_temp[x+1].append(core_dict[z])
                                               else:
                                                       for x in range(THREADS):
                                                               if CORE_MAP[x] in core_dict:
                                                                       cls.cpu_temp[x+1].append(core_dict[CORE_MAP[x]])
       
                                       elif len(cores) == THREADS / 2:
                                               cls.cpu_temp[0].append(temp)
                                               for n, t in enumerate(cores, start=1):
                                                       try:
                                                               cls.cpu_temp[n].append(t)
                                                               cls.cpu_temp[THREADS // 2 + n].append(t)
                                                       except IndexError:
                                                               break
       
                                       else:
                                               cls.cpu_temp[0].append(temp)
                                               if len(cores) > 1:
                                                       for n, t in enumerate(cores, start=1):
                                                               try:
                                                                       cls.cpu_temp[n].append(t)
                                                               except IndexError:
                                                                       break
                               except Exception as e:
                                       errlog.exception(f'{e}')
                                       cls.got_sensors = False
                                       CpuBox._calc_size()
       
                       else:
    2:                         try:
    2:                                 if cls.sensor_method == "coretemp":
                                               temp = max(0, int(subprocess.check_output(["coretemp", "-p"], universal_newlines=True).strip()))
                                               cores = [max(0, int(x)) for x in subprocess.check_output("coretemp", universal_newlines=True).split()]
                                               if len(cores) == THREADS / 2:
                                                       cls.cpu_temp[0].append(temp)
                                                       for n, t in enumerate(cores, start=1):
                                                               try:
                                                                       cls.cpu_temp[n].append(t)
                                                                       cls.cpu_temp[THREADS // 2 + n].append(t)
                                                               except IndexError:
                                                                       break
                                               else:
                                                       cores.insert(0, temp)
                                                       for n, t in enumerate(cores):
                                                               try:
                                                                       cls.cpu_temp[n].append(t)
                                                               except IndexError:
                                                                       break
                                               if not cls.cpu_temp_high:
                                                       cls.cpu_temp_high = 85
                                                       cls.cpu_temp_crit = 100
    2:                                 elif cls.sensor_method == "osx-cpu-temp":
    2:                                         temp = max(0, round(float(subprocess.check_output("osx-cpu-temp", universal_newlines=True).strip()[:-2])))
    2:                                         if not cls.cpu_temp_high:
    1:                                                 cls.cpu_temp_high = 85
    1:                                                 cls.cpu_temp_crit = 100
                                       elif cls.sensor_method == "vcgencmd":
                                               temp = max(0, round(float(subprocess.check_output(["vcgencmd", "measure_temp"], universal_newlines=True).strip()[5:-2])))
                                               if not cls.cpu_temp_high:
                                                       cls.cpu_temp_high = 60
                                                       cls.cpu_temp_crit = 80
                               except Exception as e:
                                       errlog.exception(f'{e}')
                                       cls.got_sensors = False
                                       CpuBox._calc_size()
                               else:
    2:                                 if not cores:
    2:                                         cls.cpu_temp[0].append(temp)
       
    2:                 if not core_dict and len(cores) <= 1:
    2:                         cls.cpu_temp_only = True
    2:                 if len(cls.cpu_temp[0]) > 5:
                               for n in range(len(cls.cpu_temp)):
                                       if cls.cpu_temp[n]:
                                               del cls.cpu_temp[n][0]
       
    1:         @classmethod
    1:         def _draw(cls):
    2:                 CpuBox._draw_fg()
       
    2: class MemCollector(Collector):
    1:         '''Collects memory and disks information'''
    1:         values: Dict[str, int] = {}
    1:         vlist: Dict[str, List[int]] = {}
    1:         percent: Dict[str, int] = {}
    1:         string: Dict[str, str] = {}
       
    1:         swap_values: Dict[str, int] = {}
    1:         swap_vlist: Dict[str, List[int]] = {}
    1:         swap_percent: Dict[str, int] = {}
    1:         swap_string: Dict[str, str] = {}
       
    1:         disks: Dict[str, Dict]
    1:         disk_hist: Dict[str, Tuple] = {}
    1:         timestamp: float = time()
    1:         disks_io_dict: Dict[str, Dict[str, List[int]]] = {}
    1:         recheck_diskutil: bool = True
    1:         diskutil_map: Dict[str, str] = {}
       
    1:         io_error: bool = False
       
    1:         old_disks: List[str] = []
    1:         old_io_disks: List[str] = []
       
    1:         fstab_filter: List[str] = []
       
    1:         excludes: List[str] = ["squashfs", "nullfs"]
    1:         if SYSTEM == "BSD": excludes += ["devfs", "tmpfs", "procfs", "linprocfs", "gvfs", "fusefs"]
       
    1:         buffer: str = MemBox.buffer
       
    1:         @classmethod
    1:         def _collect(cls):
                       #* Collect memory
    2:                 mem = psutil.virtual_memory()
    2:                 if hasattr(mem, "cached"):
                               cls.values["cached"] = mem.cached
                       else:
    2:                         cls.values["cached"] = mem.active
    2:                 cls.values["total"], cls.values["free"], cls.values["available"] = mem.total, mem.free, mem.available
    2:                 cls.values["used"] = cls.values["total"] - cls.values["available"]
       
   12:                 for key, value in cls.values.items():
   10:                         cls.string[key] = floating_humanizer(value)
   10:                         if key == "total": continue
    8:                         cls.percent[key] = round(value * 100 / cls.values["total"])
    8:                         if CONFIG.mem_graphs:
    8:                                 if not key in cls.vlist: cls.vlist[key] = []
    8:                                 cls.vlist[key].append(cls.percent[key])
    8:                                 if len(cls.vlist[key]) > MemBox.width: del cls.vlist[key][0]
       
                       #* Collect swap
    2:                 if CONFIG.show_swap or CONFIG.swap_disk:
    2:                         swap = psutil.swap_memory()
    2:                         cls.swap_values["total"], cls.swap_values["free"] = swap.total, swap.free
    2:                         cls.swap_values["used"] = cls.swap_values["total"] - cls.swap_values["free"]
       
    2:                         if swap.total:
    2:                                 if not MemBox.swap_on:
                                               MemBox.redraw = True
    2:                                 MemBox.swap_on = True
    8:                                 for key, value in cls.swap_values.items():
    6:                                         cls.swap_string[key] = floating_humanizer(value)
    6:                                         if key == "total": continue
    4:                                         cls.swap_percent[key] = round(value * 100 / cls.swap_values["total"])
    4:                                         if CONFIG.mem_graphs:
    4:                                                 if not key in cls.swap_vlist: cls.swap_vlist[key] = []
    4:                                                 cls.swap_vlist[key].append(cls.swap_percent[key])
    4:                                                 if len(cls.swap_vlist[key]) > MemBox.width: del cls.swap_vlist[key][0]
                               else:
                                       if MemBox.swap_on:
                                               MemBox.redraw = True
                                       MemBox.swap_on = False
                       else:
                               if MemBox.swap_on:
                                       MemBox.redraw = True
                               MemBox.swap_on = False
       
       
    2:                 if not CONFIG.show_disks: return
                       #* Collect disks usage
    2:                 disk_read: int = 0
    2:                 disk_write: int = 0
                       dev_name: str
                       disk_name: str
    2:                 filtering: Tuple = ()
    2:                 filter_exclude: bool = False
                       io_string_r: str
                       io_string_w: str
                       u_percent: int
    2:                 cls.disks = {}
       
    2:                 if CONFIG.disks_filter:
                               if CONFIG.disks_filter.startswith("exclude="):
                                       filter_exclude = True
                                       filtering = tuple(v.strip() for v in CONFIG.disks_filter.replace("exclude=", "").strip().split(","))
                               else:
                                       filtering = tuple(v.strip() for v in CONFIG.disks_filter.strip().split(","))
    2:                 try:
    2:                         io_counters = psutil.disk_io_counters(perdisk=SYSTEM != "BSD", nowrap=True)
                       except ValueError as e:
                               if not cls.io_error:
                                       cls.io_error = True
                                       errlog.error(f'Non fatal error during disk io collection!')
                                       if psutil.version_info[0] < 5 or (psutil.version_info[0] == 5 and psutil.version_info[1] < 7):
                                               errlog.error(f'Caused by outdated psutil version.')
                                       errlog.exception(f'{e}')
                               io_counters = None
       
    2:                 if SYSTEM == "MacOS" and cls.recheck_diskutil:
    2:                         cls.recheck_diskutil = False
    2:                         try:
    2:                                 dutil_out = subprocess.check_output(["diskutil", "list", "physical"], universal_newlines=True)
   18:                                 for line in dutil_out.split("\n"):
   16:                                         line = line.replace("\u2068", "").replace("\u2069", "")
   16:                                         if line.startswith("/dev/"):
    2:                                                 xdisk = line.split()[0].replace("/dev/", "")
   14:                                         elif "Container" in line:
    2:                                                 ydisk = line.split()[3]
    2:                                                 if xdisk and ydisk:
    2:                                                         cls.diskutil_map[xdisk] = ydisk
    2:                                                         xdisk = ydisk = ""
                               except:
                                       pass
       
    2:                 if CONFIG.use_fstab and SYSTEM != "MacOS" and not cls.fstab_filter:
                               try:
                                       with open('/etc/fstab','r') as fstab:
                                               for line in fstab:
                                                       line = line.strip()
                                                       if line and not line.startswith('#'):
                                                               mount_data = (line.split())
                                                               if mount_data[2].lower() != "swap":
                                                                       cls.fstab_filter += [mount_data[1]]
                                       errlog.debug(f'new fstab_filter set : {cls.fstab_filter}')
                               except IOError:
                                       CONFIG.use_fstab = False
                                       errlog.warning(f'Error reading fstab, use_fstab flag reset to {CONFIG.use_fstab}')
    2:                 if not CONFIG.use_fstab and cls.fstab_filter:
                               cls.fstab_filter = []
                               errlog.debug(f'use_fstab flag has been turned to {CONFIG.use_fstab}, fstab_filter cleared')
       
   24:                 for disk in psutil.disk_partitions(all=CONFIG.use_fstab or not CONFIG.only_physical):
   22:                         disk_io = None
   22:                         io_string_r = io_string_w = ""
   22:                         if CONFIG.use_fstab and disk.mountpoint not in cls.fstab_filter:
                                       continue
   22:                         disk_name = disk.mountpoint.rsplit('/', 1)[-1] if not disk.mountpoint == "/" else "root"
   22:                         if cls.excludes and disk.fstype in cls.excludes:
    2:                                 continue
   20:                         if filtering and ((not filter_exclude and not disk.mountpoint in filtering) or (filter_exclude and disk.mountpoint in filtering)):
                                       continue
   20:                         if SYSTEM == "MacOS" and disk.mountpoint == "/private/var/vm":
                                       continue
   20:                         try:
   20:                                 disk_u = psutil.disk_usage(disk.mountpoint)
                               except:
                                       pass
       
   20:                         u_percent = round(getattr(disk_u, "percent", 0))
   20:                         cls.disks[disk.device] = { "name" : disk_name, "used_percent" : u_percent, "free_percent" : 100 - u_percent }
   80:                         for name in ["total", "used", "free"]:
   60:                                 cls.disks[disk.device][name] = floating_humanizer(getattr(disk_u, name, 0))
       
                               #* Collect disk io
   20:                         if io_counters:
   20:                                 try:
   20:                                         if SYSTEM != "BSD":
   20:                                                 dev_name = os.path.realpath(disk.device).rsplit('/', 1)[-1]
   20:                                                 if not dev_name in io_counters:
   58:                                                         for names in io_counters:
   40:                                                                 if names in dev_name:
    2:                                                                         disk_io = io_counters[names]
    2:                                                                         break
                                                               else:
   18:                                                                 if cls.diskutil_map:
   36:                                                                         for names, items in cls.diskutil_map.items():
   18:                                                                                 if items in dev_name and names in io_counters:
   12:                                                                                         disk_io = io_counters[names]
                                                       else:
                                                               disk_io = io_counters[dev_name]
                                               elif disk.mountpoint == "/":
                                                       disk_io = io_counters
                                               else:
                                                       raise Exception
   20:                                         disk_read = round((disk_io.read_bytes - cls.disk_hist[disk.device][0]) / (time() - cls.timestamp)) #type: ignore
    7:                                         disk_write = round((disk_io.write_bytes - cls.disk_hist[disk.device][1]) / (time() - cls.timestamp)) #type: ignore
    7:                                         if not disk.device in cls.disks_io_dict:
    7:                                                 cls.disks_io_dict[disk.device] = {"read" : [], "write" : [], "rw" : []}
    7:                                         cls.disks_io_dict[disk.device]["read"].append(disk_read >> 20)
    7:                                         cls.disks_io_dict[disk.device]["write"].append(disk_write >> 20)
    7:                                         cls.disks_io_dict[disk.device]["rw"].append((disk_read + disk_write) >> 20)
       
    7:                                         if len(cls.disks_io_dict[disk.device]["read"]) > MemBox.width:
                                                       del cls.disks_io_dict[disk.device]["read"][0], cls.disks_io_dict[disk.device]["write"][0], cls.disks_io_dict[disk.device]["rw"][0]
       
   13:                                 except:
   13:                                         disk_read = disk_write = 0
                               else:
                                       disk_read = disk_write = 0
       
   20:                         if disk_io:
   14:                                 cls.disk_hist[disk.device] = (disk_io.read_bytes, disk_io.write_bytes)
   14:                                 if CONFIG.io_mode or MemBox.disks_width > 30:
   14:                                         if disk_read > 0:
    6:                                                 io_string_r = f'▲{floating_humanizer(disk_read, short=True)}'
   14:                                         if disk_write > 0:
                                                       io_string_w = f'▼{floating_humanizer(disk_write, short=True)}'
   14:                                         if CONFIG.io_mode:
                                                       cls.disks[disk.device]["io_r"] = io_string_r
                                                       cls.disks[disk.device]["io_w"] = io_string_w
                                       elif disk_read + disk_write > 0:
                                               io_string_r += f'▼▲{floating_humanizer(disk_read + disk_write, short=True)}'
       
   20:                         cls.disks[disk.device]["io"] = io_string_r + (" " if io_string_w and io_string_r else "") + io_string_w
       
    2:                 if CONFIG.swap_disk and MemBox.swap_on:
    2:                         cls.disks["__swap"] = { "name" : "swap", "used_percent" : cls.swap_percent["used"], "free_percent" : cls.swap_percent["free"], "io" : "" }
    8:                         for name in ["total", "used", "free"]:
    6:                                 cls.disks["__swap"][name] = cls.swap_string[name]
    2:                         if len(cls.disks) > 2:
    2:                                 try:
    2:                                         new = { list(cls.disks)[0] : cls.disks.pop(list(cls.disks)[0])}
    2:                                         new["__swap"] = cls.disks.pop("__swap")
    2:                                         new.update(cls.disks)
    2:                                         cls.disks = new
                                       except:
                                               pass
       
    2:                 if cls.old_disks != list(cls.disks) or cls.old_io_disks != list(cls.disks_io_dict):
    2:                         MemBox.redraw = True
    2:                         cls.recheck_diskutil = True
    2:                         cls.old_disks = list(cls.disks)
    2:                         cls.old_io_disks = list(cls.disks_io_dict)
       
    2:                 cls.timestamp = time()
       
    1:         @classmethod
    1:         def _draw(cls):
    2:                 MemBox._draw_fg()
       
    2: class NetCollector(Collector):
    1:         '''Collects network stats'''
    1:         buffer: str = NetBox.buffer
    1:         nics: List[str] = []
    1:         nic_i: int = 0
    1:         nic: str = ""
    1:         new_nic: str = ""
    1:         nic_error: bool = False
    1:         reset: bool = False
    1:         graph_raise: Dict[str, int] = {"download" : 5, "upload" : 5}
    1:         graph_lower: Dict[str, int] = {"download" : 5, "upload" : 5}
               #min_top: int = 10<<10
               #* Stats structure = stats[netword device][download, upload][total, last, top, graph_top, offset, speed, redraw, graph_raise, graph_low] = int, List[int], bool
    1:         stats: Dict[str, Dict[str, Dict[str, Any]]] = {}
               #* Strings structure strings[network device][download, upload][total, byte_ps, bit_ps, top, graph_top] = str
    1:         strings: Dict[str, Dict[str, Dict[str, str]]] = {}
    1:         switched: bool = False
    1:         timestamp: float = time()
    1:         net_min: Dict[str, int] = {"download" : -1, "upload" : -1}
    1:         auto_min: bool = CONFIG.net_auto
    1:         net_iface: str = CONFIG.net_iface
    1:         sync_top: int = 0
    1:         sync_string: str = ""
    1:         address: str = ""
       
    1:         @classmethod
    1:         def _get_nics(cls):
                       '''Get a list of all network devices sorted by highest throughput'''
    2:                 cls.nic_i = 0
    2:                 cls.nics = []
    2:                 cls.nic = ""
    2:                 try:
    2:                         io_all = psutil.net_io_counters(pernic=True)
                       except Exception as e:
                               if not cls.nic_error:
                                       cls.nic_error = True
                                       errlog.exception(f'{e}')
    2:                 if not io_all: return
    2:                 up_stat = psutil.net_if_stats()
   78:                 for nic in sorted(io_all.keys(), key=lambda nic: (getattr(io_all[nic], "bytes_recv", 0) + getattr(io_all[nic], "bytes_sent", 0)), reverse=True):
   38:                         if nic not in up_stat or not up_stat[nic].isup:
    8:                                 continue
   30:                         cls.nics.append(nic)
    2:                 if not cls.nics: cls.nics = [""]
    2:                 cls.nic = cls.nics[cls.nic_i]
    2:                 if cls.net_iface and cls.net_iface in cls.nics:
                               cls.nic = cls.net_iface
                               cls.nic_i = cls.nics.index(cls.nic)
       
       
    1:         @classmethod
    1:         def switch(cls, key: str):
                       if cls.net_iface: cls.net_iface = ""
                       if len(cls.nics) < 2 and cls.nic in cls.nics:
                               return
       
                       if cls.nic_i == -1:
                               cls.nic_i = 0 if key == "n" else -1
                       else:
                               cls.nic_i += +1 if key == "n" else -1
       
                       cls.nic_i %= len(cls.nics)
                       cls.new_nic = cls.nics[cls.nic_i]
                       cls.switched = True
                       Collector.collect(NetCollector, redraw=True)
       
    1:         @classmethod
    1:         def _collect(cls):
                       speed: int
                       stat: Dict
    2:                 up_stat = psutil.net_if_stats()
       
   42:                 if sorted(cls.nics) != sorted(nic for nic in up_stat if up_stat[nic].isup):
    1:                         old_nic = cls.nic
    1:                         cls._get_nics()
    1:                         cls.nic = old_nic
    1:                         if cls.nic not in cls.nics:
    1:                                 cls.nic_i = -1
                               else:
                                       cls.nic_i = cls.nics.index(cls.nic)
       
    2:                 if cls.switched:
                               cls.nic = cls.new_nic
                               cls.switched = False
       
    2:                 if not cls.nic or cls.nic not in up_stat:
    1:                         cls._get_nics()
    1:                         if not cls.nic: return
    1:                         NetBox.redraw = True
    2:                 try:
    2:                         io_all = psutil.net_io_counters(pernic=True)[cls.nic]
                       except KeyError:
                               pass
                               return
    2:                 if not cls.nic in cls.stats:
    1:                         cls.stats[cls.nic] = {}
    1:                         cls.strings[cls.nic] = { "download" : {}, "upload" : {}}
    3:                         for direction, value in ["download", io_all.bytes_recv], ["upload", io_all.bytes_sent]:
    2:                                 cls.stats[cls.nic][direction] = { "total" : value, "last" : value, "top" : 0, "graph_top" : 0, "offset" : 0, "speed" : [], "redraw" : True, "graph_raise" : 0, "graph_lower" : 7 }
   12:                                 for v in ["total", "byte_ps", "bit_ps", "top", "graph_top"]:
   10:                                         cls.strings[cls.nic][direction][v] = ""
       
    2:                 cls.stats[cls.nic]["download"]["total"] = io_all.bytes_recv
    2:                 cls.stats[cls.nic]["upload"]["total"] = io_all.bytes_sent
    2:                 if cls.nic in psutil.net_if_addrs():
    2:                         cls.address = getattr(psutil.net_if_addrs()[cls.nic][0], "address", "")
       
    6:                 for direction in ["download", "upload"]:
    4:                         stat = cls.stats[cls.nic][direction]
    4:                         strings = cls.strings[cls.nic][direction]
                               #* Calculate current speed
    4:                         stat["speed"].append(round((stat["total"] - stat["last"]) / (time() - cls.timestamp)))
    4:                         stat["last"] = stat["total"]
    4:                         speed = stat["speed"][-1]
       
    4:                         if cls.net_min[direction] == -1:
    2:                                 cls.net_min[direction] = units_to_bytes(getattr(CONFIG, "net_" + direction))
    2:                                 stat["graph_top"] = cls.net_min[direction]
    2:                                 stat["graph_lower"] = 7
    2:                                 if not cls.auto_min:
                                               stat["redraw"] = True
                                               strings["graph_top"] = floating_humanizer(stat["graph_top"], short=True)
       
    4:                         if stat["offset"] and stat["offset"] > stat["total"]:
                                       cls.reset = True
       
    4:                         if cls.reset:
                                       if not stat["offset"]:
                                               stat["offset"] = stat["total"]
                                       else:
                                               stat["offset"] = 0
                                       if direction == "upload":
                                               cls.reset = False
                                               NetBox.redraw = True
       
    4:                         if len(stat["speed"]) > NetBox.width * 2:
                                       del stat["speed"][0]
       
    4:                         strings["total"] = floating_humanizer(stat["total"] - stat["offset"])
    4:                         strings["byte_ps"] = floating_humanizer(stat["speed"][-1], per_second=True)
    4:                         strings["bit_ps"] = floating_humanizer(stat["speed"][-1], bit=True, per_second=True)
       
    4:                         if speed > stat["top"] or not stat["top"]:
    4:                                 stat["top"] = speed
    4:                                 strings["top"] = floating_humanizer(stat["top"], bit=True, per_second=True)
       
    4:                         if cls.auto_min:
    4:                                 if speed > stat["graph_top"]:
    2:                                         stat["graph_raise"] += 1
    2:                                         if stat["graph_lower"] > 0: stat["graph_lower"] -= 1
    2:                                 elif speed < stat["graph_top"] // 10:
    2:                                         stat["graph_lower"] += 1
    2:                                         if stat["graph_raise"] > 0: stat["graph_raise"] -= 1
       
    4:                                 if stat["graph_raise"] >= 5 or stat["graph_lower"] >= 5:
    2:                                         if stat["graph_raise"] >= 5:
                                                       stat["graph_top"] = round(max(stat["speed"][-5:]) / 0.8)
    2:                                         elif stat["graph_lower"] >= 5:
    2:                                                 stat["graph_top"] = max(10 << 10, max(stat["speed"][-5:]) * 3)
    2:                                         stat["graph_raise"] = 0
    2:                                         stat["graph_lower"] = 0
    2:                                         stat["redraw"] = True
    2:                                         strings["graph_top"] = floating_humanizer(stat["graph_top"], short=True)
       
    2:                 cls.timestamp = time()
       
    2:                 if CONFIG.net_sync:
                               c_max: int = max(cls.stats[cls.nic]["download"]["graph_top"], cls.stats[cls.nic]["upload"]["graph_top"])
                               if c_max != cls.sync_top:
                                       cls.sync_top = c_max
                                       cls.sync_string = floating_humanizer(cls.sync_top, short=True)
                                       NetBox.redraw = True
       
    1:         @classmethod
    1:         def _draw(cls):
    2:                 NetBox._draw_fg()
       
       
    2: class ProcCollector(Collector):
    1:         '''Collects process stats'''
    1:         buffer: str = ProcBox.buffer
    1:         search_filter: str = ""
    1:         case_sensitive: bool = False
    1:         processes: Dict = {}
    1:         num_procs: int = 0
    1:         det_cpu: float = 0.0
    1:         detailed: bool = False
    1:         detailed_pid: Union[int, None] = None
    1:         details: Dict[str, Any] = {}
    1:         details_cpu: List[int] = []
    1:         details_mem: List[int] = []
    1:         expand: int = 0
    1:         collapsed: Dict = {}
    1:         tree_counter: int = 0
    1:         p_values: List[str] = ["pid", "name", "cmdline", "num_threads", "username", "memory_percent", "cpu_percent", "cpu_times", "create_time"]
    1:         sort_expr: Dict = {}
    1:         sort_expr["pid"] = compile("p.info['pid']", "str", "eval")
    1:         sort_expr["program"] = compile("'' if p.info['name'] == 0.0 else p.info['name']", "str", "eval")
    1:         sort_expr["arguments"] = compile("' '.join(str(p.info['cmdline'])) or ('' if p.info['name'] == 0.0 else p.info['name'])", "str", "eval")
    1:         sort_expr["threads"] = compile("0 if p.info['num_threads'] == 0.0 else p.info['num_threads']", "str", "eval")
    1:         sort_expr["user"] = compile("'' if p.info['username'] == 0.0 else p.info['username']", "str", "eval")
    1:         sort_expr["memory"] = compile("p.info['memory_percent']", "str", "eval")
    1:         sort_expr["cpu lazy"] = compile("(sum(p.info['cpu_times'][:2] if not p.info['cpu_times'] == 0.0 else [0.0, 0.0]) * 1000 / (time() - p.info['create_time']))", "str", "eval")
    1:         sort_expr["cpu responsive"] = compile("(p.info['cpu_percent'] if CONFIG.proc_per_core else (p.info['cpu_percent'] / THREADS))", "str", "eval")
       
    1:         @classmethod
    1:         def _collect(cls):
                       '''List all processes with pid, name, arguments, threads, username, memory percent and cpu percent'''
    2:                 if not "proc" in Box.boxes: return
                       out: Dict = {}
                       cls.det_cpu = 0.0
                       sorting: str = CONFIG.proc_sorting
                       reverse: bool = not CONFIG.proc_reversed
                       proc_per_cpu: bool = CONFIG.proc_per_core
                       search: List[str] = []
                       if cls.search_filter:
                               if cls.case_sensitive:
                                       search = [i.strip() for i in cls.search_filter.split(",")]
                               else:
                                       search = [i.strip() for i in cls.search_filter.lower().split(",")]
                       err: float = 0.0
                       n: int = 0
       
                       if CONFIG.proc_tree and sorting == "arguments":
                               sorting = "program"
       
                       sort_cmd = cls.sort_expr[sorting]
       
                       if CONFIG.proc_tree:
                               cls._tree(sort_cmd=sort_cmd, reverse=reverse, proc_per_cpu=proc_per_cpu, search=search)
                       else:
                               for p in sorted(psutil.process_iter(cls.p_values + (["memory_info"] if CONFIG.proc_mem_bytes else []), err), key=lambda p: eval(sort_cmd), reverse=reverse):
                                       if cls.collect_interrupt or cls.proc_interrupt:
                                               return
                                       if p.info["name"] == "idle" or p.info["name"] == err or p.info["pid"] == err:
                                               continue
                                       if p.info["cmdline"] == err:
                                               p.info["cmdline"] = ""
                                       if p.info["username"] == err:
                                               p.info["username"] = ""
                                       if p.info["num_threads"] == err:
                                               p.info["num_threads"] = 0
                                       if search:
                                               if cls.detailed and p.info["pid"] == cls.detailed_pid:
                                                       cls.det_cpu = p.info["cpu_percent"]
                                               for value in [ p.info["name"], " ".join(p.info["cmdline"]), str(p.info["pid"]), p.info["username"] ]:
                                                       if not cls.case_sensitive:
                                                               value = value.lower()
                                                       for s in search:
                                                               if s in value:
                                                                       break
                                                       else: continue
                                                       break
                                               else: continue
       
                                       cpu = p.info["cpu_percent"] if proc_per_cpu else round(p.info["cpu_percent"] / THREADS, 2)
                                       mem = p.info["memory_percent"]
                                       if CONFIG.proc_mem_bytes and hasattr(p.info["memory_info"], "rss"):
                                               mem_b = p.info["memory_info"].rss
                                       else:
                                               mem_b = 0
       
                                       cmd = " ".join(p.info["cmdline"]) or "[" + p.info["name"] + "]"
       
                                       out[p.info["pid"]] = {
                                               "name" : p.info["name"],
                                               "cmd" : cmd,
                                               "threads" : p.info["num_threads"],
                                               "username" : p.info["username"],
                                               "mem" : mem,
                                               "mem_b" : mem_b,
                                               "cpu" : cpu }
       
                                       n += 1
       
                               cls.num_procs = n
                               cls.processes = out.copy()
       
                       if cls.detailed:
                               cls.expand = ((ProcBox.width - 2) - ((ProcBox.width - 2) // 3) - 40) // 10
                               if cls.expand > 5: cls.expand = 5
                       if cls.detailed and not cls.details.get("killed", False):
                               try:
                                       c_pid = cls.detailed_pid
                                       det = psutil.Process(c_pid)
                               except (psutil.NoSuchProcess, psutil.ZombieProcess):
                                       cls.details["killed"] = True
                                       cls.details["status"] = psutil.STATUS_DEAD
                                       ProcBox.redraw = True
                               else:
                                       attrs: List[str] = ["status", "memory_info", "create_time"]
                                       if not SYSTEM == "MacOS": attrs.extend(["cpu_num"])
                                       if cls.expand:
                                               attrs.extend(["nice", "terminal"])
                                               if not SYSTEM == "MacOS": attrs.extend(["io_counters"])
       
                                       if not c_pid in cls.processes: attrs.extend(["pid", "name", "cmdline", "num_threads", "username", "memory_percent"])
       
                                       cls.details = det.as_dict(attrs=attrs, ad_value="")
                                       if det.parent() != None: cls.details["parent_name"] = det.parent().name()
                                       else: cls.details["parent_name"] = ""
       
                                       cls.details["pid"] = c_pid
                                       if c_pid in cls.processes:
                                               cls.details["name"] = cls.processes[c_pid]["name"]
                                               cls.details["cmdline"] = cls.processes[c_pid]["cmd"]
                                               cls.details["threads"] = f'{cls.processes[c_pid]["threads"]}'
                                               cls.details["username"] = cls.processes[c_pid]["username"]
                                               cls.details["memory_percent"] = cls.processes[c_pid]["mem"]
                                               cls.details["cpu_percent"] = round(cls.processes[c_pid]["cpu"] * (1 if CONFIG.proc_per_core else THREADS))
                                       else:
                                               cls.details["cmdline"] = " ".join(cls.details["cmdline"]) or "[" + cls.details["name"] + "]"
                                               cls.details["threads"] = f'{cls.details["num_threads"]}'
                                               cls.details["cpu_percent"] = round(cls.det_cpu)
       
                                       cls.details["killed"] = False
                                       if SYSTEM == "MacOS":
                                               cls.details["cpu_num"] = -1
                                               cls.details["io_counters"] = ""
       
       
                                       if hasattr(cls.details["memory_info"], "rss"): cls.details["memory_bytes"] = floating_humanizer(cls.details["memory_info"].rss) # type: ignore
                                       else: cls.details["memory_bytes"] = "? Bytes"
       
                                       if isinstance(cls.details["create_time"], float):
                                               uptime = timedelta(seconds=round(time()-cls.details["create_time"],0))
                                               if uptime.days > 0: cls.details["uptime"] = f'{uptime.days}d {str(uptime).split(",")[1][:-3].strip()}'
                                               else: cls.details["uptime"] = f'{uptime}'
                                       else: cls.details["uptime"] = "??:??:??"
       
                                       if cls.expand:
                                               if cls.expand > 1 : cls.details["nice"] = f'{cls.details["nice"]}'
                                               if SYSTEM == "BSD":
                                                       if cls.expand > 2:
                                                               if hasattr(cls.details["io_counters"], "read_count"): cls.details["io_read"] = f'{cls.details["io_counters"].read_count}'
                                                               else: cls.details["io_read"] = "?"
                                                       if cls.expand > 3:
                                                               if hasattr(cls.details["io_counters"], "write_count"): cls.details["io_write"] = f'{cls.details["io_counters"].write_count}'
                                                               else: cls.details["io_write"] = "?"
                                               else:
                                                       if cls.expand > 2:
                                                               if hasattr(cls.details["io_counters"], "read_bytes"): cls.details["io_read"] = floating_humanizer(cls.details["io_counters"].read_bytes)
                                                               else: cls.details["io_read"] = "?"
                                                       if cls.expand > 3:
                                                               if hasattr(cls.details["io_counters"], "write_bytes"): cls.details["io_write"] = floating_humanizer(cls.details["io_counters"].write_bytes)
                                                               else: cls.details["io_write"] = "?"
                                               if cls.expand > 4 : cls.details["terminal"] = f'{cls.details["terminal"]}'.replace("/dev/", "")
       
                                       cls.details_cpu.append(cls.details["cpu_percent"])
                                       mem = cls.details["memory_percent"]
                                       if mem > 80: mem = round(mem)
                                       elif mem > 60: mem = round(mem * 1.2)
                                       elif mem > 30: mem = round(mem * 1.5)
                                       elif mem > 10: mem = round(mem * 2)
                                       elif mem > 5: mem = round(mem * 10)
                                       else: mem = round(mem * 20)
                                       cls.details_mem.append(mem)
                                       if len(cls.details_cpu) > ProcBox.width: del cls.details_cpu[0]
                                       if len(cls.details_mem) > ProcBox.width: del cls.details_mem[0]
       
    1:         @classmethod
    1:         def _tree(cls, sort_cmd, reverse: bool, proc_per_cpu: bool, search: List[str]):
                       '''List all processes in a tree view with pid, name, threads, username, memory percent and cpu percent'''
                       out: Dict = {}
                       err: float = 0.0
                       det_cpu: float = 0.0
                       infolist: Dict = {}
                       cls.tree_counter += 1
                       tree = defaultdict(list)
                       n: int = 0
                       for p in sorted(psutil.process_iter(cls.p_values + (["memory_info"] if CONFIG.proc_mem_bytes else []), err), key=lambda p: eval(sort_cmd), reverse=reverse):
                               if cls.collect_interrupt: return
                               try:
                                       tree[p.ppid()].append(p.pid)
                               except (psutil.NoSuchProcess, psutil.ZombieProcess):
                                       pass
                               else:
                                       infolist[p.pid] = p.info
                                       n += 1
                       if 0 in tree and 0 in tree[0]:
                               tree[0].remove(0)
       
                       def create_tree(pid: int, tree: defaultdict, indent: str = "", inindent: str = " ", found: bool = False, depth: int = 0, collapse_to: Union[None, int] = None):
                               nonlocal infolist, proc_per_cpu, search, out, det_cpu
                               name: str; threads: int; username: str; mem: float; cpu: float; collapse: bool = False
                               cont: bool = True
                               getinfo: Dict = {}
                               if cls.collect_interrupt: return
                               try:
                                       name = psutil.Process(pid).name()
                                       if name == "idle": return
                               except psutil.Error:
                                       pass
                                       cont = False
                                       name = ""
                               if pid in infolist:
                                       getinfo = infolist[pid]
       
                               if search and not found:
                                       if cls.detailed and pid == cls.detailed_pid:
                                               det_cpu = getinfo["cpu_percent"]
                                       if "username" in getinfo and isinstance(getinfo["username"], float): getinfo["username"] = ""
                                       if "cmdline" in getinfo and isinstance(getinfo["cmdline"], float): getinfo["cmdline"] = ""
                                       for value in [ name, str(pid), getinfo.get("username", ""), " ".join(getinfo.get("cmdline", "")) ]:
                                               if not cls.case_sensitive:
                                                       value = value.lower()
                                               for s in search:
                                                       if s in value:
                                                               found = True
                                                               break
                                               else: continue
                                               break
                                       else: cont = False
                               if cont:
                                       if getinfo:
                                               if getinfo["num_threads"] == err: threads = 0
                                               else: threads = getinfo["num_threads"]
                                               if getinfo["username"] == err: username = ""
                                               else: username = getinfo["username"]
                                               cpu = getinfo["cpu_percent"] if proc_per_cpu else round(getinfo["cpu_percent"] / THREADS, 2)
                                               mem = getinfo["memory_percent"]
                                               if getinfo["cmdline"] == err: cmd = ""
                                               else: cmd = " ".join(getinfo["cmdline"]) or "[" + getinfo["name"] + "]"
                                               if CONFIG.proc_mem_bytes and hasattr(getinfo["memory_info"], "rss"):
                                                       mem_b = getinfo["memory_info"].rss
                                               else:
                                                       mem_b = 0
                                       else:
                                               threads = mem_b = 0
                                               username = ""
                                               mem = cpu = 0.0
       
                                       if pid in cls.collapsed:
                                               collapse = cls.collapsed[pid]
                                       else:
                                               collapse = depth > CONFIG.tree_depth
                                               cls.collapsed[pid] = collapse
       
                                       if collapse_to and not search:
                                               out[collapse_to]["threads"] += threads
                                               out[collapse_to]["mem"] += mem
                                               out[collapse_to]["mem_b"] += mem_b
                                               out[collapse_to]["cpu"] += cpu
                                       else:
                                               if pid in tree and len(tree[pid]) > 0:
                                                       sign: str = "+" if collapse else "-"
                                                       inindent = inindent.replace(" ├─ ", "[" + sign + "]─").replace(" └─ ", "[" + sign + "]─")
                                               out[pid] = {
                                                       "indent" : inindent,
                                                       "name": name,
                                                       "cmd" : cmd,
                                                       "threads" : threads,
                                                       "username" : username,
                                                       "mem" : mem,
                                                       "mem_b" : mem_b,
                                                       "cpu" : cpu,
                                                       "depth" : depth,
                                                       }
       
                               if search: collapse = False
                               elif collapse and not collapse_to:
                                       collapse_to = pid
       
                               if pid not in tree:
                                       return
                               children = tree[pid][:-1]
       
                               for child in children:
                                       create_tree(child, tree, indent + " │ ", indent + " ├─ ", found=found, depth=depth+1, collapse_to=collapse_to)
                               create_tree(tree[pid][-1], tree, indent + "  ", indent + " └─ ", depth=depth+1, collapse_to=collapse_to)
       
                       create_tree(min(tree), tree)
                       cls.det_cpu = det_cpu
       
                       if cls.collect_interrupt: return
                       if cls.tree_counter >= 100:
                               cls.tree_counter = 0
                               for pid in list(cls.collapsed):
                                       if not psutil.pid_exists(pid):
                                               del cls.collapsed[pid]
                       cls.num_procs = len(out)
                       cls.processes = out.copy()
       
    1:         @classmethod
    1:         def sorting(cls, key: str):
                       index: int = CONFIG.sorting_options.index(CONFIG.proc_sorting) + (1 if key in ["right", "l"] else -1)
                       if index >= len(CONFIG.sorting_options): index = 0
                       elif index < 0: index = len(CONFIG.sorting_options) - 1
                       CONFIG.proc_sorting = CONFIG.sorting_options[index]
                       if "left" in Key.mouse: del Key.mouse["left"]
                       Collector.collect(ProcCollector, interrupt=True, redraw=True)
       
    1:         @classmethod
    1:         def _draw(cls):
    2:                 ProcBox._draw_fg()
       
    2: class Menu:
    1:         '''Holds all menus'''
    1:         active: bool = False
    1:         close: bool = False
    1:         resized: bool = True
    1:         menus: Dict[str, Dict[str, str]] = {}
    1:         menu_length: Dict[str, int] = {}
    1:         background: str = ""
    4:         for name, menu in MENUS.items():
    3:                 menu_length[name] = len(menu["normal"][0])
    3:                 menus[name] = {}
    9:                 for sel in ["normal", "selected"]:
    6:                         menus[name][sel] = ""
   24:                         for i in range(len(menu[sel])):
   18:                                 menus[name][sel] += Fx.trans(f'{Color.fg(MENU_COLORS[sel][i])}{menu[sel][i]}')
   18:                                 if i < len(menu[sel]) - 1: menus[name][sel] += f'{Mv.d(1)}{Mv.l(len(menu[sel][i]))}'
       
    1:         @classmethod
    1:         def main(cls):
                       if Term.width < 80 or Term.height < 24:
                               errlog.warning(f'The menu system only works on a terminal size of 80x24 or above!')
                               return
                       out: str = ""
                       banner: str = ""
                       redraw: bool = True
                       key: str = ""
                       mx: int = 0
                       my: int = 0
                       skip: bool = False
                       mouse_over: bool = False
                       mouse_items: Dict[str, Dict[str, int]] = {}
                       cls.active = True
                       cls.resized = True
                       menu_names: List[str] = list(cls.menus.keys())
                       menu_index: int = 0
                       menu_current: str = menu_names[0]
                       cls.background = f'{THEME.inactive_fg}' + Fx.uncolor(f'{Draw.saved_buffer()}') + f'{Term.fg}'
       
                       while not cls.close:
                               key = ""
                               if cls.resized:
                                       banner = (f'{Banner.draw(Term.height // 2 - 10, center=True)}{Mv.d(1)}{Mv.l(46)}{Colors.black_bg}{Colors.default}{Fx.b}← esc'
                                               f'{Mv.r(30)}{Fx.i}Version: {VERSION}{Fx.ui}{Fx.ub}{Term.bg}{Term.fg}')
                                       if UpdateChecker.version != VERSION:
                                               banner += f'{Mv.to(Term.height, 1)}{Fx.b}{THEME.title}New release {UpdateChecker.version} available at https://github.com/aristocratos/bpytop{Fx.ub}{Term.fg}'
                                       cy = 0
                                       for name, menu in cls.menus.items():
                                               ypos = Term.height // 2 - 2 + cy
                                               xpos = Term.width // 2 - (cls.menu_length[name] // 2)
                                               mouse_items[name] = { "x1" : xpos, "x2" : xpos + cls.menu_length[name] - 1, "y1" : ypos, "y2" : ypos + 2 }
                                               cy += 3
                                       redraw = True
                                       cls.resized = False
       
                               if redraw:
                                       out = ""
                                       for name, menu in cls.menus.items():
                                               out += f'{Mv.to(mouse_items[name]["y1"], mouse_items[name]["x1"])}{menu["selected" if name == menu_current else "normal"]}'
       
                               if skip and redraw:
                                       Draw.now(out)
                               elif not skip:
                                       Draw.now(f'{cls.background}{banner}{out}')
                               skip = redraw = False
       
                               if Key.input_wait(Timer.left(), mouse=True):
                                       if Key.mouse_moved():
                                               mx, my = Key.get_mouse()
                                               for name, pos in mouse_items.items():
                                                       if pos["x1"] <= mx <= pos["x2"] and pos["y1"] <= my <= pos["y2"]:
                                                               mouse_over = True
                                                               if name != menu_current:
                                                                       menu_current = name
                                                                       menu_index = menu_names.index(name)
                                                                       redraw = True
                                                               break
                                               else:
                                                       mouse_over = False
                                       else:
                                               key = Key.get()
       
                                       if key == "mouse_click" and not mouse_over:
                                               key = "M"
       
                                       if key == "q":
                                               clean_quit()
                                       elif key in ["escape", "M"]:
                                               cls.close = True
                                               break
                                       elif key in ["up", "mouse_scroll_up", "shift_tab"]:
                                               menu_index -= 1
                                               if menu_index < 0: menu_index = len(menu_names) - 1
                                               menu_current = menu_names[menu_index]
                                               redraw = True
                                       elif key in ["down", "mouse_scroll_down", "tab"]:
                                               menu_index += 1
                                               if menu_index > len(menu_names) - 1: menu_index = 0
                                               menu_current = menu_names[menu_index]
                                               redraw = True
                                       elif key == "enter" or (key == "mouse_click" and mouse_over):
                                               if menu_current == "quit":
                                                       clean_quit()
                                               elif menu_current == "options":
                                                       cls.options()
                                                       cls.resized = True
                                               elif menu_current == "help":
                                                       cls.help()
                                                       cls.resized = True
       
                               if Timer.not_zero() and not cls.resized:
                                       skip = True
                               else:
                                       Collector.collect()
                                       Collector.collect_done.wait(2)
                                       if CONFIG.background_update: cls.background = f'{THEME.inactive_fg}' + Fx.uncolor(f'{Draw.saved_buffer()}') + f'{Term.fg}'
                                       Timer.stamp()
       
       
                       Draw.now(f'{Draw.saved_buffer()}')
                       cls.background = ""
                       cls.active = False
                       cls.close = False
       
    1:         @classmethod
    1:         def help(cls):
                       if Term.width < 80 or Term.height < 24:
                               errlog.warning(f'The menu system only works on a terminal size of 80x24 or above!')
                               return
                       out: str = ""
                       out_misc : str = ""
                       redraw: bool = True
                       key: str = ""
                       skip: bool = False
                       main_active: bool = cls.active
                       cls.active = True
                       cls.resized = True
                       if not cls.background:
                               cls.background = f'{THEME.inactive_fg}' + Fx.uncolor(f'{Draw.saved_buffer()}') + f'{Term.fg}'
                       help_items: Dict[str, str] = {
                               "(Mouse 1)" : "Clicks buttons and selects in process list.",
                               "Selected (Mouse 1)" : "Show detailed information for selected process.",
                               "(Mouse scroll)" : "Scrolls any scrollable list/text under cursor.",
                               "(Esc, shift+m)" : "Toggles main menu.",
                               "(m)" : "Cycle view presets, order: full->proc->stat->user.",
                               "(1)" : "Toggle CPU box.",
                               "(2)" : "Toggle MEM box.",
                               "(3)" : "Toggle NET box.",
                               "(4)" : "Toggle PROC box.",
                               "(d)" : "Toggle disks view in MEM box.",
                               "(F2, o)" : "Shows options.",
                               "(F1, shift+h)" : "Shows this window.",
                               "(ctrl+z)" : "Sleep program and put in background.",
                               "(ctrl+c, q)" : "Quits program.",
                               "(+) / (-)" : "Add/Subtract 100ms to/from update timer.",
                               "(Up, k) (Down, j)" : "Select in process list.",
                               "(Enter)" : "Show detailed information for selected process.",
                               "(Spacebar)" : "Expand/collapse the selected process in tree view.",
                               "(Pg Up) (Pg Down)" : "Jump 1 page in process list.",
                               "(Home) (End)" : "Jump to first or last page in process list.",
                               "(Left, h) (Right, l)" : "Select previous/next sorting column.",
                               "(b) (n)" : "Select previous/next network device.",
                               "(s)" : "Toggle showing swap as a disk.",
                               "(i)" : "Toggle disks io mode with big graphs.",
                               "(z)" : "Toggle totals reset for current network device",
                               "(a)" : "Toggle auto scaling for the network graphs.",
                               "(y)" : "Toggle synced scaling mode for network graphs.",
                               "(f, /)" : "Input a NON case-sensitive process filter.",
                               "(shift+f)" : "Input a case-sensitive process filter.",
                               "(c)" : "Toggle per-core cpu usage of processes.",
                               "(r)" : "Reverse sorting order in processes box.",
                               "(e)" : "Toggle processes tree view.",
                               "(delete)" : "Clear any entered filter.",
                               "Selected (shift+t)" : "Terminate selected process with SIGTERM - 15.",
                               "Selected (shift+k)" : "Kill selected process with SIGKILL - 9.",
                               "Selected (shift+i)" : "Interrupt selected process with SIGINT - 2.",
                               "_1" : " ",
                               "_2" : "For bug reporting and project updates, visit:",
                               "_3" : "https://github.com/aristocratos/bpytop",
                       }
       
                       while not cls.close:
                               key = ""
                               if cls.resized:
                                       y = 8 if Term.height < len(help_items) + 10 else Term.height // 2 - len(help_items) // 2 + 4
                                       out_misc = (f'{Banner.draw(y-7, center=True)}{Mv.d(1)}{Mv.l(46)}{Colors.black_bg}{Colors.default}{Fx.b}← esc'
                                               f'{Mv.r(30)}{Fx.i}Version: {VERSION}{Fx.ui}{Fx.ub}{Term.bg}{Term.fg}')
                                       x = Term.width//2-36
                                       h, w = Term.height-2-y, 72
                                       if len(help_items) > h:
                                               pages = ceil(len(help_items) / h)
                                       else:
                                               h = len(help_items)
                                               pages = 0
                                       page = 1
                                       out_misc += create_box(x, y, w, h+3, "help", line_color=THEME.div_line)
                                       redraw = True
                                       cls.resized = False
       
                               if redraw:
                                       out = ""
                                       cy = 0
                                       if pages:
                                               out += (f'{Mv.to(y, x+56)}{THEME.div_line(Symbol.title_left)}{Fx.b}{THEME.title("pg")}{Fx.ub}{THEME.main_fg(Symbol.up)} {Fx.b}{THEME.title}{page}/{pages} '
                                               f'pg{Fx.ub}{THEME.main_fg(Symbol.down)}{THEME.div_line(Symbol.title_right)}')
                                       out += f'{Mv.to(y+1, x+1)}{THEME.title}{Fx.b}{"Keys:":^20}Description:{THEME.main_fg}'
                                       for n, (keys, desc) in enumerate(help_items.items()):
                                               if pages and n < (page - 1) * h: continue
                                               out += f'{Mv.to(y+2+cy, x+1)}{Fx.b}{("" if keys.startswith("_") else keys):^20.20}{Fx.ub}{desc:50.50}'
                                               cy += 1
                                               if cy == h: break
                                       if cy < h:
                                               for i in range(h-cy):
                                                       out += f'{Mv.to(y+2+cy+i, x+1)}{" " * (w-2)}'
       
                               if skip and redraw:
                                       Draw.now(out)
                               elif not skip:
                                       Draw.now(f'{cls.background}{out_misc}{out}')
                               skip = redraw = False
       
                               if Key.input_wait(Timer.left()):
                                       key = Key.get()
       
                                       if key == "mouse_click":
                                               mx, my = Key.get_mouse()
                                               if x <= mx < x + w and y <= my < y + h + 3:
                                                       if pages and my == y and x + 56 <  mx < x + 61:
                                                               key = "up"
                                                       elif pages and my == y and x + 63 < mx < x + 68:
                                                               key = "down"
                                               else:
                                                       key = "escape"
       
                                       if key == "q":
                                               clean_quit()
                                       elif key in ["escape", "M", "enter", "backspace", "H", "f1"]:
                                               cls.close = True
                                               break
                                       elif key in ["up", "mouse_scroll_up", "page_up"] and pages:
                                               page -= 1
                                               if page < 1: page = pages
                                               redraw = True
                                       elif key in ["down", "mouse_scroll_down", "page_down"] and pages:
                                               page += 1
                                               if page > pages: page = 1
                                               redraw = True
       
                               if Timer.not_zero() and not cls.resized:
                                       skip = True
                               else:
                                       Collector.collect()
                                       Collector.collect_done.wait(2)
                                       if CONFIG.background_update: cls.background = f'{THEME.inactive_fg}' + Fx.uncolor(f'{Draw.saved_buffer()}') + f'{Term.fg}'
                                       Timer.stamp()
       
                       if main_active:
                               cls.close = False
                               return
                       Draw.now(f'{Draw.saved_buffer()}')
                       cls.background = ""
                       cls.active = False
                       cls.close = False
       
    1:         @classmethod
    1:         def options(cls):
                       if Term.width < 80 or Term.height < 24:
                               errlog.warning(f'The menu system only works on a terminal size of 80x24 or above!')
                               return
                       out: str = ""
                       out_misc : str = ""
                       redraw: bool = True
                       selected_cat: str = ""
                       selected_int: int = 0
                       option_items: Dict[str, List[str]] = {}
                       cat_list: List[str] = []
                       cat_int: int = 0
                       change_cat: bool = False
                       key: str = ""
                       skip: bool = False
                       main_active: bool = cls.active
                       cls.active = True
                       cls.resized = True
                       d_quote: str
                       inputting: bool = False
                       input_val: str = ""
                       Theme.refresh()
                       if not cls.background:
                               cls.background = f'{THEME.inactive_fg}' + Fx.uncolor(f'{Draw.saved_buffer()}') + f'{Term.fg}'
                       categories: Dict[str, Dict[str, List[str]]] = {
                               "system" : {
                                       "color_theme" : [
                                               'Set color theme.',
                                               '',
                                               'Choose from all theme files in',
                                               '"/usr/[local/]share/bpytop/themes" and',
                                               '"~/.config/bpytop/themes".',
                                               '',
                                               '"Default" for builtin default theme.',
                                               'User themes are prefixed by a plus sign "+".',
                                               '',
                                               'For theme updates see:',
                                               'https://github.com/aristocratos/bpytop'],
                                       "theme_background" : [
                                               'If the theme set background should be shown.',
                                               '',
                                               'Set to False if you want terminal background',
                                               'transparency.'],
                                       "truecolor" : [
                                               'Sets if 24-bit truecolor should be used.',
                                               '(Requires restart to take effect!)',
                                               '',
                                               'Will convert 24-bit colors to 256 color',
                                               '(6x6x6 color cube) if False.',
                                               '',
                                               'Set to False if your terminal doesn\'t have',
                                               'truecolor support and can\'t convert to',
                                               '256-color.'],
                                       "shown_boxes" : [
                                               'Manually set which boxes to show.',
                                               '',
                                               'Available values are "cpu mem net proc".',
                                               'Seperate values with whitespace.',
                                               '',
                                               'Toggle between presets with mode key "m".'],
                                       "update_ms" : [
                                               'Update time in milliseconds.',
                                               '',
                                               'Recommended 2000 ms or above for better sample',
                                               'times for graphs.',
                                               '',
                                               'Min value: 100 ms',
                                               'Max value: 86400000 ms = 24 hours.'],
                                       "draw_clock" : [
                                               'Draw a clock at top of screen.',
                                               '(Only visible if cpu box is enabled!)',
                                               '',
                                               'Formatting according to strftime, empty',
                                               'string to disable.',
                                               '',
                                               'Custom formatting options:',
                                               '"/host" = hostname',
                                               '"/user" = username',
                                               '"/uptime" = system uptime',
                                               '',
                                               'Examples of strftime formats:',
                                               '"%X" = locale HH:MM:SS',
                                               '"%H" = 24h hour, "%I" = 12h hour',
                                               '"%M" = minute, "%S" = second',
                                               '"%d" = day, "%m" = month, "%y" = year'],
                                       "background_update" : [
                                               'Update main ui when menus are showing.',
                                               '',
                                               'True or False.',
                                               '',
                                               'Set this to false if the menus is flickering',
                                               'too much for a comfortable experience.'],
                                       "show_battery" : [
                                               'Show battery stats.',
                                               '(Only visible if cpu box is enabled!)',
                                               '',
                                               'Show battery stats in the top right corner',
                                               'if a battery is present.'],
                                       "show_init" : [
                                               'Show init screen at startup.',
                                               '',
                                               'The init screen is purely cosmetical and',
                                               'slows down start to show status messages.'],
                                       "update_check" : [
                                               'Check for updates at start.',
                                               '',
                                               'Checks for latest version from:',
                                               'https://github.com/aristocratos/bpytop'],
                                       "log_level" : [
                                               'Set loglevel for error.log',
                                               '',
                                               'Levels are: "ERROR" "WARNING" "INFO" "DEBUG".',
                                               'The level set includes all lower levels,',
                                               'i.e. "DEBUG" will show all logging info.']
                               },
                               "cpu" : {
                                       "cpu_graph_upper" : [
                                               'Sets the CPU stat shown in upper half of',
                                               'the CPU graph.',
                                               '',
                                               '"total" = Total cpu usage.',
                                               '"user" = User mode cpu usage.',
                                               '"system" = Kernel mode cpu usage.',
                                               'See:',
                                               'https://psutil.readthedocs.io/en/latest/',
                                               '#psutil.cpu_times',
                                               'for attributes available on specific platforms.'],
                                       "cpu_graph_lower" : [
                                               'Sets the CPU stat shown in lower half of',
                                               'the CPU graph.',
                                               '',
                                               '"total" = Total cpu usage.',
                                               '"user" = User mode cpu usage.',
                                               '"system" = Kernel mode cpu usage.',
                                               'See:',
                                               'https://psutil.readthedocs.io/en/latest/',
                                               '#psutil.cpu_times',
                                               'for attributes available on specific platforms.'],
                                       "cpu_invert_lower" : [
                                                       'Toggles orientation of the lower CPU graph.',
                                                       '',
                                                       'True or False.'],
                                       "cpu_single_graph" : [
                                                       'Completely disable the lower CPU graph.',
                                                       '',
                                                       'Shows only upper CPU graph and resizes it',
                                                       'to fit to box height.',
                                                       '',
                                                       'True or False.'],
                                       "check_temp" : [
                                               'Enable cpu temperature reporting.',
                                               '',
                                               'True or False.'],
                                       "cpu_sensor" : [
                                               'Cpu temperature sensor',
                                               '',
                                               'Select the sensor that corresponds to',
                                               'your cpu temperature.',
                                               'Set to "Auto" for auto detection.'],
                                       "show_coretemp" : [
                                               'Show temperatures for cpu cores.',
                                               '',
                                               'Only works if check_temp is True and',
                                               'the system is reporting core temps.'],
                                       "temp_scale" : [
                                               'Which temperature scale to use.',
                                               '',
                                               'Celsius, default scale.',
                                               '',
                                               'Fahrenheit, the american one.',
                                               '',
                                               'Kelvin, 0 = absolute zero, 1 degree change',
                                               'equals 1 degree change in Celsius.',
                                               '',
                                               'Rankine, 0 = absolute zero, 1 degree change',
                                               'equals 1 degree change in Fahrenheit.'],
                                       "show_cpu_freq" : [
                                               'Show CPU frequency',
                                               '',
                                               'Can cause slowdowns on systems with many',
                                               'cores and psutil versions below 5.8.1'],
                                       "custom_cpu_name" : [
                                               'Custom cpu model name in cpu percentage box.',
                                               '',
                                               'Empty string to disable.'],
                                       "show_uptime" : [
                                               'Shows the system uptime in the CPU box.',
                                               '',
                                               'Can also be shown in the clock by using',
                                               '"/uptime" in the formatting.',
                                               '',
                                               'True or False.'],
                               },
                               "mem" : {
                                       "mem_graphs" : [
                                               'Show graphs for memory values.',
                                               '',
                                               'True or False.'],
                                       "show_disks" : [
                                               'Split memory box to also show disks.',
                                               '',
                                               'True or False.'],
                                       "show_io_stat" : [
                                               'Toggle small IO stat graphs.',
                                               '',
                                               'Toggles the small IO graphs for the regular',
                                               'disk usage view.',
                                               '',
                                               'True or False.'],
                                       "io_mode" : [
                                               'Toggles io mode for disks.',
                                               '',
                                               'Shows big graphs for disk read/write speeds',
                                               'instead of used/free percentage meters.',
                                               '',
                                               'True or False.'],
                                       "io_graph_combined" : [
                                               'Toggle combined read and write graphs.',
                                               '',
                                               'Only has effect if "io mode" is True.',
                                               '',
                                               'True or False.'],
                                       "io_graph_speeds" : [
                                               'Set top speeds for the io graphs.',
                                               '',
                                               'Manually set which speed in MiB/s that equals',
                                               '100 percent in the io graphs.',
                                               '(10 MiB/s by default).',
                                               '',
                                               'Format: "device:speed" separate disks with a',
                                               'comma ",".',
                                               '',
                                               'Example: "/dev/sda:100, /dev/sdb:20".'],
                                       "show_swap" : [
                                               'If swap memory should be shown in memory box.',
                                               '',
                                               'True or False.'],
                                       "swap_disk" : [
                                               'Show swap as a disk.',
                                               '',
                                               'Ignores show_swap value above.',
                                               'Inserts itself after first disk.'],
                                       "only_physical" : [
                                               'Filter out non physical disks.',
                                               '',
                                               'Set this to False to include network disks,',
                                               'RAM disks and similar.',
                                               '',
                                               'True or False.'],
                                       "use_fstab" : [
                                               'Read disks list from /etc/fstab.',
                                               '(Has no effect on macOS X)',
                                               '',
                                               'This also disables only_physical.',
                                               '',
                                               'True or False.'],
                                       "disks_filter" : [
                                               'Optional filter for shown disks.',
                                               '',
                                               'Should be full path of a mountpoint,',
                                               '"root" replaces "/", separate multiple values',
                                               'with a comma ",".',
                                               'Begin line with "exclude=" to change to exclude',
                                               'filter.',
                                               'Otherwise defaults to "most include" filter.',
                                               '',
                                               'Example: disks_filter="exclude=/boot, /home/user"'],
                               },
                               "net" : {
                                       "net_download" : [
                                               'Fixed network graph download value.',
                                               '',
                                               'Default "10M" = 10 MibiBytes.',
                                               'Possible units:',
                                               '"K" (KiB), "M" (MiB), "G" (GiB).',
                                               '',
                                               'Append "bit" for bits instead of bytes,',
                                               'i.e "100Mbit"',
                                               '',
                                               'Can be toggled with auto button.'],
                                       "net_upload" : [
                                               'Fixed network graph upload value.',
                                               '',
                                               'Default "10M" = 10 MibiBytes.',
                                               'Possible units:',
                                               '"K" (KiB), "M" (MiB), "G" (GiB).',
                                               '',
                                               'Append "bit" for bits instead of bytes,',
                                               'i.e "100Mbit"',
                                               '',
                                               'Can be toggled with auto button.'],
                                       "net_auto" : [
                                               'Start in network graphs auto rescaling mode.',
                                               '',
                                               'Ignores any values set above at start and',
                                               'rescales down to 10KibiBytes at the lowest.',
                                               '',
                                               'True or False.'],
                                       "net_sync" : [
                                               'Network scale sync.',
                                               '',
                                               'Syncs the scaling for download and upload to',
                                               'whichever currently has the highest scale.',
                                               '',
                                               'True or False.'],
                                       "net_color_fixed" : [
                                               'Set network graphs color gradient to fixed.',
                                               '',
                                               'If True the network graphs color is based',
                                               'on the total bandwidth usage instead of',
                                               'the current autoscaling.',
                                               '',
                                               'The bandwidth usage is based on the',
                                               '"net_download" and "net_upload" values set',
                                               'above.'],
                                       "net_iface" : [
                                               'Network Interface.',
                                               '',
                                               'Manually set the starting Network Interface.',
                                               'Will otherwise automatically choose the NIC',
                                               'with the highest total download since boot.'],
                               },
                               "proc" : {
                                       "proc_update_mult" : [
                                               'Processes update multiplier.',
                                               'Sets how often the process list is updated as',
                                               'a multiplier of "update_ms".',
                                               '',
                                               'Set to 2 or higher to greatly decrease bpytop',
                                               'cpu usage. (Only integers)'],
                                       "proc_sorting" : [
                                               'Processes sorting option.',
                                               '',
                                               'Possible values: "pid", "program", "arguments",',
                                               '"threads", "user", "memory", "cpu lazy" and',
                                               '"cpu responsive".',
                                               '',
                                               '"cpu lazy" updates top process over time,',
                                               '"cpu responsive" updates top process directly.'],
                                       "proc_reversed" : [
                                               'Reverse processes sorting order.',
                                               '',
                                               'True or False.'],
                                       "proc_tree" : [
                                               'Processes tree view.',
                                               '',
                                               'Set true to show processes grouped by parents,',
                                               'with lines drawn between parent and child',
                                               'process.'],
                                       "tree_depth" : [
                                               'Process tree auto collapse depth.',
                                               '',
                                               'Sets the depth where the tree view will auto',
                                               'collapse processes at.'],
                                       "proc_colors" : [
                                               'Enable colors in process view.',
                                               '',
                                               'Uses the cpu graph gradient colors.'],
                                       "proc_gradient" : [
                                               'Enable process view gradient fade.',
                                               '',
                                               'Fades from top or current selection.',
                                               'Max fade value is equal to current themes',
                                               '"inactive_fg" color value.'],
                                       "proc_per_core" : [
                                               'Process usage per core.',
                                               '',
                                               'If process cpu usage should be of the core',
                                               'it\'s running on or usage of the total',
                                               'available cpu power.',
                                               '',
                                               'If true and process is multithreaded',
                                               'cpu usage can reach over 100%.'],
                                       "proc_mem_bytes" : [
                                               'Show memory as bytes in process list.',
                                               ' ',
                                               'True or False.'],
                               }
                       }
       
                       loglevel_i: int = CONFIG.log_levels.index(CONFIG.log_level)
                       cpu_sensor_i: int = CONFIG.cpu_sensors.index(CONFIG.cpu_sensor)
                       cpu_graph_i: Dict[str, int] = { "cpu_graph_upper" : CONFIG.cpu_percent_fields.index(CONFIG.cpu_graph_upper),
                                                                                       "cpu_graph_lower" : CONFIG.cpu_percent_fields.index(CONFIG.cpu_graph_lower)}
                       temp_scale_i: int = CONFIG.temp_scales.index(CONFIG.temp_scale)
                       color_i: int
                       max_opt_len: int = max([len(categories[x]) for x in categories]) * 2
                       cat_list = list(categories)
                       while not cls.close:
                               key = ""
                               if cls.resized or change_cat:
                                       cls.resized = change_cat = False
                                       selected_cat = list(categories)[cat_int]
                                       option_items = categories[cat_list[cat_int]]
                                       option_len: int = len(option_items) * 2
                                       y = 12 if Term.height < max_opt_len + 13 else Term.height // 2 - max_opt_len // 2 + 7
                                       out_misc = (f'{Banner.draw(y-10, center=True)}{Mv.d(1)}{Mv.l(46)}{Colors.black_bg}{Colors.default}{Fx.b}← esc'
                                               f'{Mv.r(30)}{Fx.i}Version: {VERSION}{Fx.ui}{Fx.ub}{Term.bg}{Term.fg}')
                                       x = Term.width//2-38
                                       x2 = x + 27
                                       h, w, w2 = min(Term.height-1-y, option_len), 26, 50
                                       h -= h % 2
                                       color_i = list(Theme.themes).index(THEME.current)
                                       out_misc += create_box(x, y - 3, w+w2+1, 3, f'tab{Symbol.right}', line_color=THEME.div_line)
                                       out_misc += create_box(x, y, w, h+2, "options", line_color=THEME.div_line)
                                       redraw = True
       
                                       cat_width = floor((w+w2) / len(categories))
                                       out_misc += f'{Fx.b}'
                                       for cx, cat in enumerate(categories):
                                               out_misc += f'{Mv.to(y-2, x + 1 + (cat_width * cx) + round(cat_width / 2 - len(cat) / 2 ))}'
                                               if cat == selected_cat:
                                                       out_misc += f'{THEME.hi_fg}[{THEME.title}{Fx.u}{cat}{Fx.uu}{THEME.hi_fg}]'
                                               else:
                                                       out_misc += f'{THEME.hi_fg}{SUPERSCRIPT[cx+1]}{THEME.title}{cat}'
                                       out_misc += f'{Fx.ub}'
                                       if option_len > h:
                                               pages = ceil(option_len / h)
                                       else:
                                               h = option_len
                                               pages = 0
                                       page = pages if selected_int == -1 and pages > 0 else 1
                                       selected_int = 0 if selected_int >= 0 else len(option_items) - 1
                               if redraw:
                                       out = ""
                                       cy = 0
       
                                       selected = list(option_items)[selected_int]
                                       if pages:
                                               out += (f'{Mv.to(y+h+1, x+11)}{THEME.div_line(Symbol.title_left)}{Fx.b}{THEME.title("pg")}{Fx.ub}{THEME.main_fg(Symbol.up)} {Fx.b}{THEME.title}{page}/{pages} '
                                               f'pg{Fx.ub}{THEME.main_fg(Symbol.down)}{THEME.div_line(Symbol.title_right)}')
                                       #out += f'{Mv.to(y+1, x+1)}{THEME.title}{Fx.b}{"Keys:":^20}Description:{THEME.main_fg}'
                                       for n, opt in enumerate(option_items):
                                               if pages and n < (page - 1) * ceil(h / 2): continue
                                               value = getattr(CONFIG, opt)
                                               t_color = f'{THEME.selected_bg}{THEME.selected_fg}' if opt == selected else f'{THEME.title}'
                                               v_color = "" if opt == selected else f'{THEME.title}'
                                               d_quote = '"' if isinstance(value, str) else ""
                                               if opt == "color_theme":
                                                       counter = f' {color_i + 1}/{len(Theme.themes)}'
                                               elif opt == "proc_sorting":
                                                       counter = f' {CONFIG.sorting_options.index(CONFIG.proc_sorting) + 1}/{len(CONFIG.sorting_options)}'
                                               elif opt == "log_level":
                                                       counter = f' {loglevel_i + 1}/{len(CONFIG.log_levels)}'
                                               elif opt == "cpu_sensor":
                                                       counter = f' {cpu_sensor_i + 1}/{len(CONFIG.cpu_sensors)}'
                                               elif opt in ["cpu_graph_upper", "cpu_graph_lower"]:
                                                       counter = f' {cpu_graph_i[opt] + 1}/{len(CONFIG.cpu_percent_fields)}'
                                               elif opt == "temp_scale":
                                                       counter = f' {temp_scale_i + 1}/{len(CONFIG.temp_scales)}'
                                               else:
                                                       counter = ""
                                               out += f'{Mv.to(y+1+cy, x+1)}{t_color}{Fx.b}{opt.replace("_", " ").capitalize() + counter:^24.24}{Fx.ub}{Mv.to(y+2+cy, x+1)}{v_color}'
                                               if opt == selected:
                                                       if isinstance(value, bool) or opt in ["color_theme", "proc_sorting", "log_level", "cpu_sensor", "cpu_graph_upper", "cpu_graph_lower", "temp_scale"]:
                                                               out += f'{t_color} {Symbol.left}{v_color}{d_quote + str(value) + d_quote:^20.20}{t_color}{Symbol.right} '
                                                       elif inputting:
                                                               out += f'{str(input_val)[-17:] + Fx.bl + "█" + Fx.ubl + "" + Symbol.enter:^33.33}'
                                                       else:
                                                               out += ((f'{t_color} {Symbol.left}{v_color}' if type(value) is int else "  ") +
                                                               f'{str(value) + " " + Symbol.enter:^20.20}' + (f'{t_color}{Symbol.right} ' if type(value) is int else "  "))
                                               else:
                                                       out += f'{d_quote + str(value) + d_quote:^24.24}'
                                               out += f'{Term.bg}'
                                               if opt == selected:
                                                       h2 = len(option_items[opt]) + 2
                                                       y2 = y + (selected_int * 2) - ((page-1) * h)
                                                       if y2 + h2 > Term.height: y2 = Term.height - h2
                                                       out += f'{create_box(x2, y2, w2, h2, "description", line_color=THEME.div_line)}{THEME.main_fg}'
                                                       for n, desc in enumerate(option_items[opt]):
                                                               out += f'{Mv.to(y2+1+n, x2+2)}{desc:.48}'
                                               cy += 2
                                               if cy >= h: break
                                       if cy < h:
                                               for i in range(h-cy):
                                                       out += f'{Mv.to(y+1+cy+i, x+1)}{" " * (w-2)}'
       
       
                               if not skip or redraw:
                                       Draw.now(f'{cls.background}{out_misc}{out}')
                               skip = redraw = False
       
                               if Key.input_wait(Timer.left()):
                                       key = Key.get()
                                       redraw = True
                                       has_sel = False
                                       if key == "mouse_click" and not inputting:
                                               mx, my = Key.get_mouse()
                                               if x < mx < x + w + w2 and y - 4 < my < y:
                                                       # if my == y - 2:
                                                       for cx, cat in enumerate(categories):
                                                               ccx = x + (cat_width * cx) + round(cat_width / 2 - len(cat) / 2 )
                                                               if ccx - 2 < mx < ccx + 2 + len(cat):
                                                                       key = str(cx+1)
                                                                       break
                                               elif x < mx < x + w and y < my < y + h + 2:
                                                       mouse_sel = ceil((my - y) / 2) - 1 + ceil((page-1) * (h / 2))
                                                       if pages and my == y+h+1 and x+11 < mx < x+16:
                                                               key = "page_up"
                                                       elif pages and my == y+h+1 and x+19 < mx < x+24:
                                                               key = "page_down"
                                                       elif my == y+h+1:
                                                               pass
                                                       elif mouse_sel == selected_int:
                                                               if mx < x + 6:
                                                                       key = "left"
                                                               elif mx > x + 19:
                                                                       key = "right"
                                                               else:
                                                                       key = "enter"
                                                       elif mouse_sel < len(option_items):
                                                               selected_int = mouse_sel
                                                               has_sel = True
                                               else:
                                                       key = "escape"
                                       if inputting:
                                               if key in ["escape", "mouse_click"]:
                                                       inputting = False
                                               elif key == "enter":
                                                       inputting = False
                                                       if str(getattr(CONFIG, selected)) != input_val:
                                                               if selected == "update_ms":
                                                                       if not input_val or int(input_val) < 100:
                                                                               CONFIG.update_ms = 100
                                                                       elif int(input_val) > 86399900:
                                                                               CONFIG.update_ms = 86399900
                                                                       else:
                                                                               CONFIG.update_ms = int(input_val)
                                                               elif selected == "proc_update_mult":
                                                                       if not input_val or int(input_val) < 1:
                                                                               CONFIG.proc_update_mult = 1
                                                                       else:
                                                                               CONFIG.proc_update_mult = int(input_val)
                                                                       Collector.proc_counter = 1
                                                               elif selected == "tree_depth":
                                                                       if not input_val or int(input_val) < 0:
                                                                               CONFIG.tree_depth = 0
                                                                       else:
                                                                               CONFIG.tree_depth = int(input_val)
                                                                       ProcCollector.collapsed = {}
                                                               elif selected == "shown_boxes":
                                                                       new_boxes: List = []
                                                                       for box in input_val.split():
                                                                               if box in ["cpu", "mem", "net", "proc"]:
                                                                                       new_boxes.append(box)
                                                                       CONFIG.shown_boxes = " ".join(new_boxes)
                                                                       Box.view_mode = "user"
                                                                       Box.view_modes["user"] = CONFIG.shown_boxes.split()
                                                                       Draw.clear(saved=True)
                                                               elif isinstance(getattr(CONFIG, selected), str):
                                                                       setattr(CONFIG, selected, input_val)
                                                                       if selected.startswith("net_"):
                                                                               NetCollector.net_min = {"download" : -1, "upload" : -1}
                                                                       elif selected == "draw_clock":
                                                                               Box.clock_on = len(CONFIG.draw_clock) > 0
                                                                               if not Box.clock_on: Draw.clear("clock", saved=True)
                                                                       elif selected == "io_graph_speeds":
                                                                               MemBox.graph_speeds = {}
                                                               Term.refresh(force=True)
                                                               cls.resized = False
                                               elif key == "backspace" and len(input_val):
                                                       input_val = input_val[:-1]
                                               elif key == "delete":
                                                       input_val = ""
                                               elif isinstance(getattr(CONFIG, selected), str) and len(key) == 1:
                                                       input_val += key
                                               elif isinstance(getattr(CONFIG, selected), int) and key.isdigit():
                                                       input_val += key
                                       elif key == "q":
                                               clean_quit()
                                       elif key in ["escape", "o", "M", "f2"]:
                                               cls.close = True
                                               break
                                       elif key == "tab" or (key == "down" and selected_int == len(option_items) - 1 and page in [0, pages]):
                                               if cat_int == len(categories) - 1:
                                                       cat_int = 0
                                               else:
                                                       cat_int += 1
                                               change_cat = True
                                       elif key == "shift_tab" or (key == "up" and selected_int == 0 and page == 1):
                                               if cat_int == 0:
                                                       cat_int = len(categories) - 1
                                               else:
                                                       cat_int -= 1
                                               change_cat = True
                                               selected_int = -1 if key != "shift_tab" else 0
                                       elif key in list(map(str, range(1, len(cat_list)+1))) and key != str(cat_int + 1):
                                               cat_int = int(key) - 1
                                               change_cat = True
                                       elif key == "enter" and selected in ["update_ms", "disks_filter", "custom_cpu_name", "net_download",
                                                "net_upload", "draw_clock", "tree_depth", "proc_update_mult", "shown_boxes", "net_iface", "io_graph_speeds"]:
                                               inputting = True
                                               input_val = str(getattr(CONFIG, selected))
                                       elif key == "left" and selected == "update_ms" and CONFIG.update_ms - 100 >= 100:
                                               CONFIG.update_ms -= 100
                                               Box.draw_update_ms()
                                       elif key == "right" and selected == "update_ms" and CONFIG.update_ms + 100 <= 86399900:
                                               CONFIG.update_ms += 100
                                               Box.draw_update_ms()
                                       elif key == "left" and selected == "proc_update_mult" and CONFIG.proc_update_mult > 1:
                                               CONFIG.proc_update_mult -= 1
                                               Collector.proc_counter = 1
                                       elif key == "right" and selected == "proc_update_mult":
                                               CONFIG.proc_update_mult += 1
                                               Collector.proc_counter = 1
                                       elif key == "left" and selected == "tree_depth" and CONFIG.tree_depth > 0:
                                               CONFIG.tree_depth -= 1
                                               ProcCollector.collapsed = {}
                                       elif key == "right" and selected == "tree_depth":
                                               CONFIG.tree_depth += 1
                                               ProcCollector.collapsed = {}
                                       elif key in ["left", "right"] and isinstance(getattr(CONFIG, selected), bool):
                                               setattr(CONFIG, selected, not getattr(CONFIG, selected))
                                               if selected == "check_temp":
                                                       if CONFIG.check_temp:
                                                               CpuCollector.get_sensors()
                                                       else:
                                                               CpuCollector.sensor_method = ""
                                                               CpuCollector.got_sensors = False
                                               if selected in ["net_auto", "net_color_fixed", "net_sync"]:
                                                       if selected == "net_auto": NetCollector.auto_min = CONFIG.net_auto
                                                       NetBox.redraw = True
                                               if selected == "theme_background":
                                                       Term.bg = f'{THEME.main_bg}' if CONFIG.theme_background else "\033[49m"
                                                       Draw.now(Term.bg)
                                               if selected == "show_battery":
                                                       Draw.clear("battery", saved=True)
                                               Term.refresh(force=True)
                                               cls.resized = False
                                       elif key in ["left", "right"] and selected == "color_theme" and len(Theme.themes) > 1:
                                               if key == "left":
                                                       color_i -= 1
                                                       if color_i < 0: color_i = len(Theme.themes) - 1
                                               elif key == "right":
                                                       color_i += 1
                                                       if color_i > len(Theme.themes) - 1: color_i = 0
                                               Collector.collect_idle.wait()
                                               CONFIG.color_theme = list(Theme.themes)[color_i]
                                               THEME(CONFIG.color_theme)
                                               Term.refresh(force=True)
                                               Timer.finish()
                                       elif key in ["left", "right"] and selected == "proc_sorting":
                                               ProcCollector.sorting(key)
                                       elif key in ["left", "right"] and selected == "log_level":
                                               if key == "left":
                                                       loglevel_i -= 1
                                                       if loglevel_i < 0: loglevel_i = len(CONFIG.log_levels) - 1
                                               elif key == "right":
                                                       loglevel_i += 1
                                                       if loglevel_i > len(CONFIG.log_levels) - 1: loglevel_i = 0
                                               CONFIG.log_level = CONFIG.log_levels[loglevel_i]
                                               errlog.setLevel(getattr(logging, CONFIG.log_level))
                                               errlog.info(f'Loglevel set to {CONFIG.log_level}')
                                       elif key in ["left", "right"] and selected in ["cpu_graph_upper", "cpu_graph_lower"]:
                                               if key == "left":
                                                       cpu_graph_i[selected] -= 1
                                                       if cpu_graph_i[selected] < 0: cpu_graph_i[selected] = len(CONFIG.cpu_percent_fields) - 1
                                               if key == "right":
                                                       cpu_graph_i[selected] += 1
                                                       if cpu_graph_i[selected] > len(CONFIG.cpu_percent_fields) - 1: cpu_graph_i[selected] = 0
                                               setattr(CONFIG, selected, CONFIG.cpu_percent_fields[cpu_graph_i[selected]])
                                               setattr(CpuCollector, selected.replace("_graph", ""), [])
                                               Term.refresh(force=True)
                                               cls.resized = False
                                       elif key in ["left", "right"] and selected == "temp_scale":
                                               if key == "left":
                                                       temp_scale_i -= 1
                                                       if temp_scale_i < 0: temp_scale_i = len(CONFIG.temp_scales) - 1
                                               if key == "right":
                                                       temp_scale_i += 1
                                                       if temp_scale_i > len(CONFIG.temp_scales) - 1: temp_scale_i = 0
                                               CONFIG.temp_scale = CONFIG.temp_scales[temp_scale_i]
                                               Term.refresh(force=True)
                                               cls.resized = False
                                       elif key in ["left", "right"] and selected == "cpu_sensor" and len(CONFIG.cpu_sensors) > 1:
                                               if key == "left":
                                                       cpu_sensor_i -= 1
                                                       if cpu_sensor_i < 0: cpu_sensor_i = len(CONFIG.cpu_sensors) - 1
                                               elif key == "right":
                                                       cpu_sensor_i += 1
                                                       if cpu_sensor_i > len(CONFIG.cpu_sensors) - 1: cpu_sensor_i = 0
                                               Collector.collect_idle.wait()
                                               CpuCollector.sensor_swap = True
                                               CONFIG.cpu_sensor = CONFIG.cpu_sensors[cpu_sensor_i]
                                               if CONFIG.check_temp and (CpuCollector.sensor_method != "psutil" or CONFIG.cpu_sensor == "Auto"):
                                                       CpuCollector.get_sensors()
                                                       Term.refresh(force=True)
                                                       cls.resized = False
                                       elif key in ["up", "mouse_scroll_up"]:
                                               selected_int -= 1
                                               if selected_int < 0: selected_int = len(option_items) - 1
                                               page = floor(selected_int * 2 / h) + 1
                                       elif key in ["down", "mouse_scroll_down"]:
                                               selected_int += 1
                                               if selected_int > len(option_items) - 1: selected_int = 0
                                               page = floor(selected_int * 2 / h) + 1
                                       elif key == "page_up":
                                               if not pages or page == 1:
                                                       selected_int = 0
                                               else:
                                                       page -= 1
                                                       if page < 1: page = pages
                                               selected_int = (page-1) * ceil(h / 2)
                                       elif key == "page_down":
                                               if not pages or page == pages:
                                                       selected_int = len(option_items) - 1
                                               else:
                                                       page += 1
                                                       if page > pages: page = 1
                                                       selected_int = (page-1) * ceil(h / 2)
                                       elif has_sel:
                                               pass
                                       else:
                                               redraw = False
       
                               if Timer.not_zero() and not cls.resized:
                                       skip = True
                               else:
                                       Collector.collect()
                                       Collector.collect_done.wait(2)
                                       if CONFIG.background_update: cls.background = f'{THEME.inactive_fg}' + Fx.uncolor(f'{Draw.saved_buffer()}') + f'{Term.fg}'
                                       Timer.stamp()
       
                       if main_active:
                               cls.close = False
                               return
                       Draw.now(f'{Draw.saved_buffer()}')
                       cls.background = ""
                       cls.active = False
                       cls.close = False
       
    2: class Timer:
    1:         timestamp: float
    1:         return_zero = False
       
    1:         @classmethod
    1:         def stamp(cls):
    2:                 cls.timestamp = time()
       
    1:         @classmethod
    1:         def not_zero(cls) -> bool:
    3:                 if cls.return_zero:
    1:                         cls.return_zero = False
    1:                         return False
    2:                 return cls.timestamp + (CONFIG.update_ms / 1000) > time()
       
    1:         @classmethod
    1:         def left(cls) -> float:
    2:                 t_left: float = cls.timestamp + (CONFIG.update_ms / 1000) - time()
    2:                 if t_left > CONFIG.update_ms / 1000:
                               cls.stamp()
                               return CONFIG.update_ms / 1000
    2:                 return t_left
       
    1:         @classmethod
    1:         def finish(cls):
    1:                 cls.return_zero = True
    1:                 cls.timestamp = time() - (CONFIG.update_ms / 1000)
    1:                 Key.break_wait()
       
    2: class UpdateChecker:
    1:         version: str = VERSION
    1:         thread: threading.Thread
       
    1:         @classmethod
    1:         def run(cls):
    1:                 cls.thread = threading.Thread(target=cls._checker)
    1:                 cls.thread.start()
       
    1:         @classmethod
    1:         def _checker(cls):
    1:                 try:
    1:                         with urllib.request.urlopen("https://github.com/aristocratos/bpytop/raw/master/bpytop.py", timeout=5) as source: # type: ignore
                                       for line in source:
                                               line = line.decode("utf-8")
                                               if line.startswith("VERSION: str ="):
                                                       cls.version = line[(line.index("=")+1):].strip('" \n')
                                                       break
    1:                 except Exception as e:
    1:                         errlog.exception(f'{e}')
                       else:
                               if cls.version != VERSION and which("notify-send"):
                                       try:
                                               subprocess.run(["notify-send", "-u", "normal", "BpyTop Update!",
                                                       f'New version of BpyTop available!\nCurrent version: {VERSION}\nNew version: {cls.version}\nDownload at github.com/aristocratos/bpytop',
                                                       "-i", "update-notifier", "-t", "10000"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                                       except Exception as e:
                                               errlog.exception(f'{e}')
       
    2: class Init:
    1:         running: bool = True
    1:         initbg_colors: List[str] = []
    1:         initbg_data: List[int]
    1:         initbg_up: Graph
    1:         initbg_down: Graph
    1:         resized = False
       
    1:         @classmethod
    1:         def start(cls):
                       Draw.buffer("init", z=1)
                       Draw.buffer("initbg", z=10)
                       for i in range(51):
                               for _ in range(2): cls.initbg_colors.append(Color.fg(i, i, i))
                       Draw.buffer("banner", (f'{Banner.draw(Term.height // 2 - 10, center=True)}{Mv.d(1)}{Mv.l(11)}{Colors.black_bg}{Colors.default}'
                                       f'{Fx.b}{Fx.i}Version: {VERSION}{Fx.ui}{Fx.ub}{Term.bg}{Term.fg}{Color.fg("#50")}'), z=2)
                       for _i in range(7):
                               perc = f'{str(round((_i + 1) * 14 + 2)) + "%":>5}'
                               Draw.buffer("+banner", f'{Mv.to(Term.height // 2 - 2 + _i, Term.width // 2 - 28)}{Fx.trans(perc)}{Symbol.v_line}')
       
                       Draw.out("banner")
                       Draw.buffer("+init!", f'{Color.fg("#cc")}{Fx.b}{Mv.to(Term.height // 2 - 2, Term.width // 2 - 21)}{Mv.save}')
       
                       cls.initbg_data = [randint(0, 100) for _ in range(Term.width * 2)]
                       cls.initbg_up = Graph(Term.width, Term.height // 2, cls.initbg_colors, cls.initbg_data, invert=True)
                       cls.initbg_down = Graph(Term.width, Term.height // 2, cls.initbg_colors, cls.initbg_data, invert=False)
       
    1:         @classmethod
    1:         def success(cls):
    7:                 if not CONFIG.show_init or cls.resized: return
                       cls.draw_bg(5)
                       Draw.buffer("+init!", f'{Mv.restore}{Symbol.ok}\n{Mv.r(Term.width // 2 - 22)}{Mv.save}')
       
    1:         @staticmethod
    1:         def fail(err):
                       if CONFIG.show_init:
                               Draw.buffer("+init!", f'{Mv.restore}{Symbol.fail}')
                               sleep(2)
                       errlog.exception(f'{err}')
                       clean_quit(1, errmsg=f'Error during init! See {CONFIG_DIR}/error.log for more information.')
       
    1:         @classmethod
    1:         def draw_bg(cls, times: int = 5):
                       for _ in range(times):
                               sleep(0.05)
                               x = randint(0, 100)
                               Draw.buffer("initbg", f'{Fx.ub}{Mv.to(0, 0)}{cls.initbg_up(x)}{Mv.to(Term.height // 2, 0)}{cls.initbg_down(x)}')
                               Draw.out("initbg", "banner", "init")
       
    1:         @classmethod
    1:         def done(cls):
    1:                 cls.running = False
    1:                 if not CONFIG.show_init: return
                       if cls.resized:
                               Draw.now(Term.clear)
                       else:
                               cls.draw_bg(10)
                       Draw.clear("initbg", "banner", "init", saved=True)
                       if cls.resized: return
                       del cls.initbg_up, cls.initbg_down, cls.initbg_data, cls.initbg_colors
       
       
       #? Functions ------------------------------------------------------------------------------------->
       
    1: def get_cpu_name() -> str:
               '''Fetch a suitable CPU identifier from the CPU model name string'''
    1:         name: str = ""
    1:         nlist: List = []
    1:         command: str = ""
    1:         cmd_out: str = ""
    1:         rem_line: str = ""
    1:         if SYSTEM == "Linux":
                       command = "cat /proc/cpuinfo"
                       rem_line = "model name"
    1:         elif SYSTEM == "MacOS":
    1:                 command ="sysctl -n machdep.cpu.brand_string"
               elif SYSTEM == "BSD":
                       command ="sysctl hw.model"
                       rem_line = "hw.model"
       
    1:         try:
    1:                 cmd_out = subprocess.check_output("LANG=C " + command, shell=True, universal_newlines=True)
               except:
                       pass
    1:         if rem_line:
                       for line in cmd_out.split("\n"):
                               if rem_line in line:
                                       name = re.sub( ".*" + rem_line + ".*:", "", line,1).lstrip()
               else:
    1:                 name = cmd_out
    1:         nlist = name.split(" ")
    1:         try:
    1:                 if "Xeon" in name and "CPU" in name:
                               name = nlist[nlist.index("CPU")+(-1 if name.endswith(("CPU", "z")) else 1)]
    1:                 elif "Ryzen" in name:
                               name = " ".join(nlist[nlist.index("Ryzen"):nlist.index("Ryzen")+3])
    1:                 elif "Duo" in name and "@" in name:
                               name = " ".join(nlist[:nlist.index("@")])
    1:                 elif "CPU" in name and not nlist[0] == "CPU" and not nlist[nlist.index("CPU")-1].isdigit():
                               name = nlist[nlist.index("CPU")-1]
               except:
                       pass
       
    1:         name = name.replace("Processor", "").replace("CPU", "").replace("(R)", "").replace("(TM)", "").replace("Intel", "")
    1:         name = re.sub(r"\d?\.?\d+[mMgG][hH][zZ]", "", name)
    1:         name = " ".join(name.split())
       
    1:         return name
       
    1: def get_cpu_core_mapping() -> List[int]:
    1:         mapping: List[int] = []
    1:         core_ids: List[int] = []
       
    1:         if SYSTEM == "Linux" and os.path.isfile("/proc/cpuinfo"):
                       try:
                               mapping = [0] * THREADS
                               num = 0
                               with open("/proc/cpuinfo", "r") as f:
                                       for line in f:
                                               if line.startswith("processor"):
                                                       num = int(line.strip()[(line.index(": ")+2):])
                                                       if num > THREADS - 1:
                                                               break
                                               elif line.startswith("core id"):
                                                       core_id = int(line.strip()[(line.index(": ")+2):])
                                                       if core_id not in core_ids:
                                                               core_ids.append(core_id)
                                                       mapping[num] = core_ids.index(core_id)
                               if num < THREADS - 1:
                                       raise Exception
                       except:
                               mapping = []
       
    1:         if not mapping:
    1:                 mapping = []
    2:                 for _ in range(THREADS // CORES):
   10:                         mapping.extend([x for x in range(CORES)])
       
    1:         return mapping
       
    1: def create_box(x: int = 0, y: int = 0, width: int = 0, height: int = 0, title: str = "", title2: str = "", line_color: Color = None, title_color: Color = None, fill: bool = True, box = None) -> str:
               '''Create a box from a box object or by given arguments'''
   16:         out: str = f'{Term.fg}{Term.bg}'
   16:         num: int = 0
   16:         if not line_color: line_color = THEME.div_line
   16:         if not title_color: title_color = THEME.title
       
               #* Get values from box class if given
   16:         if box:
   10:                 x = box.x
   10:                 y = box.y
   10:                 width = box.width
   10:                 height = box.height
   10:                 title = box.name
   10:                 num = box.num
   16:         hlines: Tuple[int, int] = (y, y + height - 1)
       
   16:         out += f'{line_color}'
       
               #* Draw all horizontal lines
   48:         for hpos in hlines:
   32:                 out += f'{Mv.to(hpos, x)}{Symbol.h_line * (width - 1)}'
       
               #* Draw all vertical lines and fill if enabled
  128:         for hpos in range(hlines[0]+1, hlines[1]):
  112:                 out += f'{Mv.to(hpos, x)}{Symbol.v_line}{" " * (width-2) if fill else Mv.r(width-2)}{Symbol.v_line}'
       
               #* Draw corners
  112:         out += f'{Mv.to(y, x)}{Symbol.left_up}\
   32:         {Mv.to(y, x + width - 1)}{Symbol.right_up}\
   32:         {Mv.to(y + height - 1, x)}{Symbol.left_down}\
   32:         {Mv.to(y + height - 1, x + width - 1)}{Symbol.right_down}'
       
               #* Draw titles if enabled
   16:         if title:
   16:                 numbered: str = "" if not num else f'{THEME.hi_fg(SUPERSCRIPT[num])}'
   16:                 out += f'{Mv.to(y, x + 2)}{Symbol.title_left}{Fx.b}{numbered}{title_color}{title}{Fx.ub}{line_color}{Symbol.title_right}'
   16:         if title2:
    4:                 out += f'{Mv.to(hlines[1], x + 2)}{Symbol.title_left}{title_color}{Fx.b}{title2}{Fx.ub}{line_color}{Symbol.title_right}'
       
   16:         return f'{out}{Term.fg}{Mv.to(y + 1, x + 1)}'
       
    1: def now_sleeping(signum, frame):
               """Reset terminal settings and stop background input read before putting to sleep"""
               Key.stop()
               Collector.stop()
               Draw.now(Term.clear, Term.normal_screen, Term.show_cursor, Term.mouse_off, Term.mouse_direct_off, Term.title())
               Term.echo(True)
               os.kill(os.getpid(), signal.SIGSTOP)
       
    1: def now_awake(signum, frame):
               """Set terminal settings and restart background input read"""
               Draw.now(Term.alt_screen, Term.clear, Term.hide_cursor, Term.mouse_on, Term.title("BpyTOP"))
               Term.echo(False)
               Key.start()
               Term.refresh()
               Box.calc_sizes()
               Box.draw_bg()
               Collector.start()
       
    1: def quit_sigint(signum, frame):
               """SIGINT redirection to clean_quit()"""
               clean_quit()
       
    1: def clean_quit(errcode: int = 0, errmsg: str = "", thread: bool = False):
               """Stop background input read, save current config and reset terminal settings before quitting"""
               global THREAD_ERROR
    1:         if thread:
                       THREAD_ERROR = errcode
                       interrupt_main()
                       return
    1:         if THREAD_ERROR: errcode = THREAD_ERROR
    1:         Key.stop()
    1:         Collector.stop()
    1:         if not errcode: CONFIG.save_config()
    1:         Draw.now(Term.clear, Term.normal_screen, Term.show_cursor, Term.mouse_off, Term.mouse_direct_off, Term.title())
    1:         Term.echo(True)
    1:         if errcode == 0:
    1:                 errlog.info(f'Exiting. Runtime {timedelta(seconds=round(time() - SELF_START, 0))} \n')
               else:
                       errlog.warning(f'Exiting with errorcode ({errcode}). Runtime {timedelta(seconds=round(time() - SELF_START, 0))} \n')
                       if not errmsg: errmsg = f'Bpytop exited with errorcode ({errcode}). See {CONFIG_DIR}/error.log for more information!'
    1:         if errmsg: print(errmsg)
       
    1:         raise SystemExit(errcode)
       
    1: def floating_humanizer(value: Union[float, int], bit: bool = False, per_second: bool = False, start: int = 0, short: bool = False) -> str:
               '''Scales up in steps of 1024 to highest possible unit and returns string with unit suffixed
               * bit=True or defaults to bytes
               * start=int to set 1024 multiplier starting unit
               * short=True always returns 0 decimals and shortens unit to 1 character
               '''
  100:         out: str = ""
  100:         mult: int = 8 if bit else 1
  100:         selector: int = start
  100:         unit: Tuple[str, ...] = UNITS["bit"] if bit else UNITS["byte"]
       
  100:         if isinstance(value, float): value = round(value * 100 * mult)
  100:         elif value > 0: value *= 100 * mult
    6:         else: value = 0
       
  328:         while len(f'{value}') > 5 and value >= 102400:
  228:                 value >>= 10
  228:                 if value < 100:
                               out = f'{value}'
                               break
  228:                 selector += 1
               else:
  100:                 if len(f'{value}') == 4 and selector > 0:
   32:                         out = f'{value}'[:-2] + "." + f'{value}'[-2]
   68:                 elif len(f'{value}') == 3 and selector > 0:
   16:                         out = f'{value}'[:-2] + "." + f'{value}'[-2:]
   52:                 elif len(f'{value}') >= 2:
   46:                         out = f'{value}'[:-2]
                       else:
    6:                         out = f'{value}'
       
       
  100:         if short:
    8:                 if "." in out:
    8:                         out = f'{round(float(out))}'
    8:                 if len(out) > 3:
                               out = f'{int(out[0]) + 1}'
                               selector += 1
  100:         out += f'{"" if short else " "}{unit[selector][0] if short else unit[selector]}'
  100:         if per_second: out += "ps" if bit else "/s"
       
  100:         return out
       
    1: def units_to_bytes(value: str) -> int:
    2:         if not value: return 0
    2:         out: int = 0
    2:         mult: int = 0
    2:         bit: bool = False
    2:         value_i: int = 0
    2:         units: Dict[str, int] = {"k" : 1, "m" : 2, "g" : 3}
    2:         try:
    2:                 if value.lower().endswith("s"):
                               value = value[:-1]
    2:                 if value.lower().endswith("bit"):
                               bit = True
                               value = value[:-3]
    2:                 elif value.lower().endswith("byte"):
                               value = value[:-4]
       
    2:                 if value[-1].lower() in units:
    2:                         mult = units[value[-1].lower()]
    2:                         value = value[:-1]
       
    2:                 if "." in value and value.replace(".", "").isdigit():
                               if mult > 0:
                                       value_i = round(float(value) * 1024)
                                       mult -= 1
                               else:
                                       value_i = round(float(value))
    2:                 elif value.isdigit():
    2:                         value_i = int(value)
       
    2:                 out = int(value_i) << (10 * mult)
    2:                 if bit: out = round(out / 8)
               except ValueError:
                       out = 0
    2:         return out
       
    1: def min_max(value: int, min_value: int=0, max_value: int=100) -> int:
   34:         return max(min_value, min(value, max_value))
       
    1: def readfile(file: str, default: str = "") -> str:
               out: Union[str, None] = None
               if os.path.isfile(file):
                       try:
                               with open(file, "r") as f:
                                       out = f.read().strip()
                       except:
                               pass
               return default if out is None else out
       
    1: def temperature(value: int, scale: str = "celsius") -> Tuple[int, str]:
               """Returns a tuple with integer value and string unit converted from an integer in celsius to: celsius, fahrenheit, kelvin or rankine."""
    2:         if scale == "celsius":
    2:                 return (value, "°C")
               elif scale == "fahrenheit":
                       return (round(value * 1.8 + 32), "°F")
               elif scale == "kelvin":
                       return (round(value + 273.15), "K ")
               elif scale == "rankine":
                       return (round(value * 1.8 + 491.67), "°R")
               else:
                       return (0, "")
       
    1: def process_keys():
    2:         mouse_pos: Tuple[int, int] = (0, 0)
    2:         filtered: bool = False
    2:         box_keys = {"1" : "cpu", "2" : "mem", "3" : "net", "4" : "proc"}
    3:         while Key.has_key():
    2:                 key = Key.get()
    2:                 found: bool = True
    2:                 if key in ["mouse_scroll_up", "mouse_scroll_down", "mouse_click"]:
                               mouse_pos = Key.get_mouse()
                               if mouse_pos[0] >= ProcBox.x and ProcBox.current_y + 1 <= mouse_pos[1] < ProcBox.current_y + ProcBox.current_h - 1:
                                       pass
                               elif key == "mouse_click":
                                       key = "mouse_unselect"
                               else:
                                       key = "_null"
       
    2:                 if ProcBox.filtering:
                               if key in ["enter", "mouse_click", "mouse_unselect"]:
                                       ProcBox.filtering = False
                                       Collector.collect(ProcCollector, redraw=True, only_draw=True)
                                       continue
                               elif key in ["escape", "delete"]:
                                       ProcCollector.search_filter = ""
                                       ProcBox.filtering = False
                               elif len(key) == 1:
                                       ProcCollector.search_filter += key
                               elif key == "backspace" and len(ProcCollector.search_filter) > 0:
                                       ProcCollector.search_filter = ProcCollector.search_filter[:-1]
                               else:
                                       continue
                               Collector.collect(ProcCollector, proc_interrupt=True, redraw=True)
                               if filtered: Collector.collect_done.wait(0.1)
                               filtered = True
                               continue
       
    2:                 if key == "_null":
    1:                         continue
    1:                 elif key == "q":
    1:                         clean_quit()
                       elif key == "+" and CONFIG.update_ms + 100 <= 86399900:
                               CONFIG.update_ms += 100
                               Box.draw_update_ms()
                       elif key == "-" and CONFIG.update_ms - 100 >= 100:
                               CONFIG.update_ms -= 100
                               Box.draw_update_ms()
                       elif key in ["M", "escape"]:
                               Menu.main()
                       elif key in ["o", "f2"]:
                               Menu.options()
                       elif key in ["H", "f1"]:
                               Menu.help()
                       elif key == "m":
                               if list(Box.view_modes).index(Box.view_mode) + 1 > len(list(Box.view_modes)) - 1:
                                       Box.view_mode = list(Box.view_modes)[0]
                               else:
                                       Box.view_mode = list(Box.view_modes)[(list(Box.view_modes).index(Box.view_mode) + 1)]
                               CONFIG.shown_boxes = " ".join(Box.view_modes[Box.view_mode])
                               Draw.clear(saved=True)
                               Term.refresh(force=True)
                       elif key in box_keys:
                               boxes = CONFIG.shown_boxes.split()
                               if box_keys[key] in boxes:
                                       boxes.remove(box_keys[key])
                               else:
                                       boxes.append(box_keys[key])
                               CONFIG.shown_boxes = " ".join(boxes)
                               Box.view_mode = "user"
                               Box.view_modes["user"] = CONFIG.shown_boxes.split()
                               Draw.clear(saved=True)
                               Term.refresh(force=True)
                       else:
                               found = False
       
                       if found: continue
       
                       if "proc" in Box.boxes:
                               if key in ["left", "right", "h", "l"]:
                                       ProcCollector.sorting(key)
                               elif key == " " and CONFIG.proc_tree and ProcBox.selected > 0:
                                       if ProcBox.selected_pid in ProcCollector.collapsed:
                                               ProcCollector.collapsed[ProcBox.selected_pid] = not ProcCollector.collapsed[ProcBox.selected_pid]
                                       Collector.collect(ProcCollector, interrupt=True, redraw=True)
                               elif key == "e":
                                       CONFIG.proc_tree = not CONFIG.proc_tree
                                       Collector.collect(ProcCollector, interrupt=True, redraw=True)
                               elif key == "r":
                                       CONFIG.proc_reversed = not CONFIG.proc_reversed
                                       Collector.collect(ProcCollector, interrupt=True, redraw=True)
                               elif key == "c":
                                       CONFIG.proc_per_core = not CONFIG.proc_per_core
                                       Collector.collect(ProcCollector, interrupt=True, redraw=True)
                               elif key in ["f", "F", "/"]:
                                       ProcBox.filtering = True
                                       ProcCollector.case_sensitive = key == "F"
                                       if not ProcCollector.search_filter: ProcBox.start = 0
                                       Collector.collect(ProcCollector, redraw=True, only_draw=True)
                               elif key in ["T", "K", "I"] and (ProcBox.selected > 0 or ProcCollector.detailed):
                                       pid: int = ProcBox.selected_pid if ProcBox.selected > 0 else ProcCollector.detailed_pid # type: ignore
                                       if psutil.pid_exists(pid):
                                               if key == "T": sig = signal.SIGTERM
                                               elif key == "K": sig = signal.SIGKILL
                                               elif key == "I": sig = signal.SIGINT
                                               try:
                                                       os.kill(pid, sig)
                                               except Exception as e:
                                                       errlog.error(f'Exception when sending signal {sig} to pid {pid}')
                                                       errlog.exception(f'{e}')
                               elif key == "delete" and ProcCollector.search_filter:
                                       ProcCollector.search_filter = ""
                                       Collector.collect(ProcCollector, proc_interrupt=True, redraw=True)
                               elif key == "enter":
                                       if ProcBox.selected > 0 and ProcCollector.detailed_pid != ProcBox.selected_pid and psutil.pid_exists(ProcBox.selected_pid):
                                               ProcCollector.detailed = True
                                               ProcBox.last_selection = ProcBox.selected
                                               ProcBox.selected = 0
                                               ProcCollector.detailed_pid = ProcBox.selected_pid
                                               ProcBox.resized = True
                                               Collector.proc_counter = 1
                                       elif ProcCollector.detailed:
                                               ProcBox.selected = ProcBox.last_selection
                                               ProcBox.last_selection = 0
                                               ProcCollector.detailed = False
                                               ProcCollector.detailed_pid = None
                                               ProcBox.resized = True
                                               Collector.proc_counter = 1
                                       else:
                                               continue
                                       ProcCollector.details = {}
                                       ProcCollector.details_cpu = []
                                       ProcCollector.details_mem = []
                                       Graphs.detailed_cpu = NotImplemented
                                       Graphs.detailed_mem = NotImplemented
                                       Collector.collect(ProcCollector, proc_interrupt=True, redraw=True)
                               elif key in ["up", "down", "mouse_scroll_up", "mouse_scroll_down", "page_up", "page_down", "home", "end", "mouse_click", "mouse_unselect", "j", "k"]:
                                       ProcBox.selector(key, mouse_pos)
       
                       if "net" in Box.boxes:
                               if key in ["b", "n"]:
                                       NetCollector.switch(key)
                               elif key == "z":
                                       NetCollector.reset = not NetCollector.reset
                                       Collector.collect(NetCollector, redraw=True)
                               elif key == "y":
                                       CONFIG.net_sync = not CONFIG.net_sync
                                       Collector.collect(NetCollector, redraw=True)
                               elif key == "a":
                                       NetCollector.auto_min = not NetCollector.auto_min
                                       NetCollector.net_min = {"download" : -1, "upload" : -1}
                                       Collector.collect(NetCollector, redraw=True)
       
                       if "mem" in Box.boxes:
                               if key == "g":
                                       CONFIG.mem_graphs = not CONFIG.mem_graphs
                                       Collector.collect(MemCollector, interrupt=True, redraw=True)
                               elif key == "s":
                                       Collector.collect_idle.wait()
                                       CONFIG.swap_disk = not CONFIG.swap_disk
                                       Collector.collect(MemCollector, interrupt=True, redraw=True)
                               elif key == "d":
                                       Collector.collect_idle.wait()
                                       CONFIG.show_disks = not CONFIG.show_disks
                                       Collector.collect(MemCollector, interrupt=True, redraw=True)
                               elif key == "i":
                                       Collector.collect_idle.wait()
                                       CONFIG.io_mode = not CONFIG.io_mode
                                       Collector.collect(MemCollector, interrupt=True, redraw=True)
       
       
       
       
       
       #? Pre main -------------------------------------------------------------------------------------->
       
       
    1: CPU_NAME: str = get_cpu_name()
       
    1: CORE_MAP: List[int] = get_cpu_core_mapping()
       
    1: THEME: Theme
       
    1: def main():
               global THEME
       
    1:         Term.width = os.get_terminal_size().columns
    1:         Term.height = os.get_terminal_size().lines
       
               #? Init -------------------------------------------------------------------------------------->
    1:         if DEBUG: TimeIt.start("Init")
       
               #? Switch to alternate screen, clear screen, hide cursor, enable mouse reporting and disable input echo
    1:         Draw.now(Term.alt_screen, Term.clear, Term.hide_cursor, Term.mouse_on, Term.title("BpyTOP"))
    1:         Term.echo(False)
               #Term.refresh(force=True)
       
               #? Start a thread checking for updates while running init
    1:         if CONFIG.update_check: UpdateChecker.run()
       
               #? Draw banner and init status
    1:         if CONFIG.show_init and not Init.resized:
                       Init.start()
       
               #? Load theme
    1:         if CONFIG.show_init:
                       Draw.buffer("+init!", f'{Mv.restore}{Fx.trans("Loading theme and creating colors... ")}{Mv.save}')
    1:         try:
    1:                 THEME = Theme(CONFIG.color_theme)
               except Exception as e:
                       Init.fail(e)
               else:
    1:                 Init.success()
       
               #? Setup boxes
    1:         if CONFIG.show_init:
                       Draw.buffer("+init!", f'{Mv.restore}{Fx.trans("Doing some maths and drawing... ")}{Mv.save}')
    1:         try:
    1:                 if CONFIG.check_temp: CpuCollector.get_sensors()
    1:                 Box.calc_sizes()
    1:                 Box.draw_bg(now=False)
               except Exception as e:
                       Init.fail(e)
               else:
    1:                 Init.success()
       
               #? Setup signal handlers for SIGSTP, SIGCONT, SIGINT and SIGWINCH
    1:         if CONFIG.show_init:
                       Draw.buffer("+init!", f'{Mv.restore}{Fx.trans("Setting up signal handlers... ")}{Mv.save}')
    1:         try:
    1:                 signal.signal(signal.SIGTSTP, now_sleeping) #* Ctrl-Z
    1:                 signal.signal(signal.SIGCONT, now_awake)        #* Resume
    1:                 signal.signal(signal.SIGINT, quit_sigint)       #* Ctrl-C
    1:                 signal.signal(signal.SIGWINCH, Term.refresh) #* Terminal resized
               except Exception as e:
                       Init.fail(e)
               else:
    1:                 Init.success()
       
               #? Start a separate thread for reading keyboard input
    1:         if CONFIG.show_init:
                       Draw.buffer("+init!", f'{Mv.restore}{Fx.trans("Starting input reader thread... ")}{Mv.save}')
    1:         try:
    1:                 if isinstance(sys.stdin, io.TextIOWrapper) and sys.version_info >= (3, 7):
    1:                         sys.stdin.reconfigure(errors="ignore")  # type: ignore
    1:                 Key.start()
               except Exception as e:
                       Init.fail(e)
               else:
    1:                 Init.success()
       
               #? Start a separate thread for data collection and drawing
    1:         if CONFIG.show_init:
                       Draw.buffer("+init!", f'{Mv.restore}{Fx.trans("Starting data collection and drawer thread... ")}{Mv.save}')
    1:         try:
    1:                 Collector.start()
               except Exception as e:
                       Init.fail(e)
               else:
    1:                 Init.success()
       
               #? Collect data and draw to buffer
    1:         if CONFIG.show_init:
                       Draw.buffer("+init!", f'{Mv.restore}{Fx.trans("Collecting data and drawing... ")}{Mv.save}')
    1:         try:
    1:                 Collector.collect(draw_now=False)
    1:                 pass
               except Exception as e:
                       Init.fail(e)
               else:
    1:                 Init.success()
       
               #? Draw to screen
    1:         if CONFIG.show_init:
                       Draw.buffer("+init!", f'{Mv.restore}{Fx.trans("Finishing up... ")}{Mv.save}')
    1:         try:
    1:                 Collector.collect_done.wait()
               except Exception as e:
                       Init.fail(e)
               else:
    1:                 Init.success()
       
    1:         Init.done()
    1:         Term.refresh()
    1:         Draw.out(clear=True)
    1:         if CONFIG.draw_clock:
    1:                 Box.clock_on = True
    1:         if DEBUG: TimeIt.stop("Init")
       
               #? Main loop ------------------------------------------------------------------------------------->
       
    1:         def run():
                       while not False:
    2:                         Term.refresh()
    2:                         Timer.stamp()
       
    3:                         while Timer.not_zero():
    2:                                 if Key.input_wait(Timer.left()):
    2:                                         process_keys()
       
    1:                         Collector.collect()
       
               #? Start main loop
    1:         try:
    1:                 run()
    1:         except Exception as e:
                       errlog.exception(f'{e}')
                       clean_quit(1)
               else:
                       #? Quit cleanly even if false starts being true...
                       clean_quit()
       
       
    1: if __name__ == "__main__":
    1:         main()
